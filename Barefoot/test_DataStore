#! /usr/bin/perl -w

use strict;

use Barefoot::debug(1);					# comment out for production use

use Carp;
use POSIX qw<strftime>;

use Barefoot::base;
use Barefoot::range;
use Barefoot::DataStore;
use Barefoot::exception;

sub test_error(&@);


# alert to testing user
my $server = "SYBASE_1";
print "\nNOTICE: This script requires a certain amount of setup.\n";
print "Make sure the following things are true if you have problems:\n";
print "    1) The server $server is up and running.\n";
print "    2) You have the sa password in your .dbpasswd file.\n";
print "    3) The database 'testdb' exists.\n";
print "    4) The user 'buddy' a valid user in testdb.\n";
print "    5) The user 'guest' is a valid user in testdb.\n\n";

# test failure to find data store
test_error
{
	my $dsfail = DataStore->open("bogus");
}
catch { /data store bogus not found/ }
or die("bogus data store didn't throw not found error");

# test weird I/O errors by faking a data store file
test_error
{
	open(DS, ">fake.dstore") and close(DS);
	my $dsfail = DataStore->open("fake");
}
catch { /read error opening data store/ }
or die("fake data store didn't cause weird I/O error");
unlink("fake.dstore");


# test creating a new data store
my $newds = DataStore->create("new", user => "nobody");
die("didn't get a blank data store") unless $newds;
die("not blessed ref (DataStore)") unless $newds->isa("DataStore");

# print STDERR "calling dtor via undef\n";
undef $newds;
die("didn't create data store file upon destruction") unless -e "new.dstore";

# test to make sure open() requires a user
test_error
{
	$newds = DataStore->open("new");
}
catch { /must specify user/ }
or die("open didn't require user");

$newds = DataStore->open("new", "nobody");
die("couldn't retrieve newly created data store") unless $newds;
# print STDERR "newds is a ", ref $newds, "\n";
die("not blessed ref (DataStore)") unless $newds->isa("DataStore");


# make sure it doesn't save unless it's been modified
unlink("new.dstore");
# print STDERR "calling dtor via undef\n";
undef $newds;
die("saved data store spec w/o being modified") if -e "new.dstore";


# check to make sure create() catches bogus attributes
test_error
{
	my $bogusds = DataStore->create("bogus_attrib", bogus => "bogus");
}
catch { /can't create data store with unknown attribute bogus/ }
or die("create didn't notice bogus attribute");
die("created file with bogus attribute") if -e "bogus_attrib.dstore";


# make sure a bogus user bombs
test_error
{
	my $testds = DataStore->create("test",
		connect_string		=>	"dbi:Sybase:server=$server",
		server				=>	$server,
		user				=>	"bogus",
	);
}
catch { /can't get db password/ }
or die("didn't detect bogus user");


# make sure a bogus database bombs
test_error
{
	print STDERR "BOGUS ERROR => ";
	my $testds = DataStore->create("test",
		connect_string		=>	"dbi:Sybase:server=$server;database=bogus",
		server				=>	$server,
		user				=>	"sa",
	);
}
catch { /can't connect to data store as user/ }
or die("didn't detect bogus database");


# now let's create a datastore we can play with
use constant TEST_DS_FILE => "test.dstore";
my $testds = DataStore->create("test",
		connect_string		=>	"dbi:Sybase:server=$server;database=testdb",
		server				=>	$server,
		user				=>	"sa",
		translation_type	=>	"Sybase",
);

# check file creation after committing config changes
unlink(TEST_DS_FILE);
$testds->commit_configs();
die("didn't create data store after commit configs") unless -e TEST_DS_FILE;

# can we get one row?
my $sysobjquery = "
		select name, crdate
		from sysobjects
		where name = 'sysobjects'
";
my $results = $testds->do($sysobjquery);
die("got no results (query 1)") unless $results;
die("results aren't blessed properly")
		unless $results->isa("DataStore::ResultSet");
$results->next_row();
die("incorrect number of columns") unless $results->num_cols() == 2;
die("results are not correct")
		unless $results->col("name") eq "sysobjects"
		and $results->col("crdate") eq "Jan  1 1900 12:00AM";

# what happens if you ask for an invalid column?
test_error
{
	my $x = $results->col("bogus");
}
catch { /unknown column name bogus/ }
or die("didn't catch illegal column name");

# can we get more than one row?
$sysobjquery = "
		select name
		from sysobjects
		where name like 'sysc%'
";
$results = $testds->do($sysobjquery);
die("got no results (query 2)") unless $results;
die("incorrect number of columns") unless $results->num_cols() == 1;
my @correct_results = qw<syscolumns syscomments sysconstraints>;
my $count = 0;
while ($results->next_row())
{
	# print STDERR "row ", $count + 1, " value :", $results->col(0), ":\n";
	die("row " . ($count + 1) . " has incorrect value")
			unless $results->col(0) eq $correct_results[$count];
	++$count;
}


# make sure we can create tables
die("didn't gracefully handle illegal table name")
		if $testds->overwrite_table("%", [ ['a', 'char(1)', 'null'] ]);

die("can't create table: " . $testds->last_error())
		unless $testds->overwrite_table("test1", [
				[ 'a', 'char(3)', 'not null' ],
				[ 'b', 'date', 'null' ],
				[ 'c', 'money', 'null' ],
		]);

# and put data in ...
use constant NUM_TEST_ROWS => 15;
my $insquery = "insert test1 values ('xxx', '1/1/2002', 48.35)\n";
$insquery x= NUM_TEST_ROWS;
$results = $testds->do($insquery);
die("can't insert values properly: " . $testds->last_error()) unless $results;
$results = $testds->do("insert test1 select * from test1");
die("can't insert select properly: " . $testds->last_error()) unless $results;
my $nrows = $results->rows_affected();
die("didn't get proper number of rows (got $nrows)")
		unless $nrows == NUM_TEST_ROWS;

# ... and get data back out
$results = $testds->do("select * from test1");
$count = 0;
while ($results->next_row())
{
	++$count;
	die("column 0 bad for row $count") unless $results->col(0) eq 'xxx';
	die("bad name for column 0") unless $results->colname(0) eq 'a';
	# print STDERR $results->col(1), "\n";
	die("column 1 bad for row $count")
			unless $results->col(1) eq 'Jan  1 2002 12:00AM';
	die("bad name for column 1") unless $results->colname(1) eq 'b';
	die("column 2 bad for row $count") unless $results->col(2) == 48.35;
	die("bad name for column 2") unless $results->colname(2) eq 'c';
}
die("didn't get proper number of rows back")
		unless $count == NUM_TEST_ROWS * 2;

test_constants();
test_bogus_function();
test_indices();
test_misc_functions();
test_user_types();
test_schema_trans();
test_execute();
test_vars();
test_calc_columns();

# make sure we can reopen our data store
undef $testds;
print STDERR "about to reopen test data store\n" if DEBUG >= 5;
$testds = DataStore->open("test", "buddy");
print STDERR "modified state is $testds->{modified}\n" if DEBUG >= 4;

# quick output check
test_output("select * from {~dbo}.test1 where a = 'xxx'",
		"xxx:Jan  1 2002 12:00AM:48.35\n" x (NUM_TEST_ROWS * 2),
		"can't get good data on reopen");

# for following tests, we need some permissions
$testds = DataStore->open("test", "sa");

test_load_append_replace();
test_show_queries();
test_transactions();

# clean up our test stuff
$testds = DataStore->open("test", "sa");	# have to be sa for this to work
db_assert($testds->do("drop table test1"), "can't drop test table");
db_assert($testds->do("drop table {~buddy}.test1"), "can't drop test table");
db_assert($testds->do("drop table {~guest}.test1"), "can't drop test table");
# if we don't do the below, running the test script enough times will
# eventually fill up the transaction log and then we're hosed
db_assert($testds->do("dump tran testdb with no_log"), "can't dump tran");
unlink(TEST_DS_FILE);

# looks okay
unlink "new.dstore";
print "ALL TESTS PASSED\n";


#
# Subroutines:
#


sub db_assert
{
	my ($condition, $die_msg) = @_;

	die("$die_msg: " . $testds->last_error()) unless $condition;
}


sub test_error (&@)
{
	my ($try, $catch) = @_;

	# print STDERR "in test_error block\n";
	eval { &$try };
	if ($@)
	{
		# print "in try: $@";
		$@ =~ /^(.*) at (.*) line (\d+)(?:.*\.)?\n$/;
		die("incorrect 'die' format: $@") unless $3;
		local $_ = $1;
		print STDERR "actually caught $_\n" if DEBUG >= 2;
		$__FILE__ = $2;
		$__LINE__ = $3;
		return true if &$catch;
	}
	return false;
}


sub test_output
{
	my ($query, $expected_output, $die_msg) = @_;

	# print STDERR "about to do $query\n";
	my $res = $testds->do($query);
	croak("test_output query failed: " . $testds->last_error())
			unless defined $res;
	my $output = "";
	$output .= join(':', $res->all_cols()) . "\n" while $res->next_row();
	print STDERR "got output $output\n" if DEBUG >= 2;
	croak($die_msg) unless $output eq $expected_output;
}


sub test_constants
{
	db_assert($testds->do("insert test1 "
			. "values ('con', {BEGINNING_OF_TIME}, 0)"),
			"beginning of time insert failed");
	db_assert($testds->do("insert test1 "
			. "values ('con', {END_OF_TIME}, 0)"),
			"end of time insert failed");
	test_output("select * from test1 where a = 'con'",
			"con:Jan  1 1753 12:00AM:0\ncon:Dec 31 9999 12:00AM:0\n",
			"incorrect data stored for constants");
}

sub test_bogus_function
{
	test_error
	{
		$testds->do("{&bogus}");
	}
	catch { /unknown translation function: bogus/ }
	or die("didn't detect bogus function");
}

sub test_user_types
{
	# now make some user defined types
	$testds->configure_type('logical', 'boolean');

	# while we're here, make sure we can't call do() with config's pending
	test_error
	{
		$testds->do("something");
	}
	catch { /can't execute query with config's pending; run commit_configs()/ }
	or die("didn't refuse query with pending config's");

	# now make sure our defined type works
	$testds->commit_configs();
	die("can't create table with user types: " . $testds->last_error())
			unless $testds->overwrite_table("test2", [
					[ 'a', 'char(3)', 'not null' ],
					[ 'b', 'logical', 'null' ],
			]);
}

sub test_indices
{
	# first try to make an index
	db_assert($testds->do("create index t1 on test1 (a) {&place_on 'default'}"),
			"can't create an index (function place_on)");

	# now try to drop it
	db_assert($testds->do("{&drop_index test1, t1}"),
			"can't drop an index (function drop_index");
}

sub test_misc_functions
{
	# curdate function
	my $res = $testds->do("select {&curdate}");
	croak("curdate query failed:", $testds->last_error())
			unless defined $res and $res->next_row();
	# note: if you happen to be running this at the exact moment of midnight,
	# I suppose it's technically possible for the Sybase date and the Unix
	# date to fail to match.  just run it again.
	print STDERR "current date: from data store = ",
			substr($res->col(0), 0, 11), ", from Perl = ",
			strftime("%b %e %Y", localtime(time())), "\n" if DEBUG >= 2;
	die("can't get current date")
			unless substr($res->col(0), 0, 11)
					eq strftime("%b %e %Y", localtime(time()));

	# ifnull function
	db_assert($testds->do("
			insert test1 values ('nul', null, 123.45)
			insert test1 values ('nul', null, null)
			insert test1 values ('nul', null, 99.99)
	"), "couldn't insert data to test ifnull func");
	test_output("select {&ifnull c, 99.99} from test1 where a = 'nul' "
			. "order by c", "99.99\n99.99\n123.45\n",
			"test of ifnull func failed");
}

sub test_schema_trans
{
	# define a schema translation
	$testds->configure_schema_translation('return "$_[0].";');
	$testds->commit_configs();
	$testds->overwrite_table('{~guest}.test1', [['a', 'int', 'null']])
			or die("can't create initial table for schema testing");
	db_assert(
			$testds->overwrite_table('{~buddy}.test1', [['a', 'int', 'null']]),
			"can't create same table in different schema: "
	);
}

sub test_execute
{
	db_assert(
			$testds->execute("
				insert test2
				values ('xxx', 1)
				;
				insert test2
				values ('xyz', 0)
				;
			"),
			"basic execute failed"
	);
	test_output("select * from test2 where a like 'x%'", "xxx:1\nxyz:0\n",
			"didn't get correct data back from execute");

	db_assert(
			$testds->execute("
				insert test2
				values ('abc', 1)
				bmoogle		
				insert test2
				values ('aaa', 0)
				bmoogle      
			", delim => "bmoogle"),
			"execute with alternate delimiter failed"
	);
	test_output("select * from test2 where a like 'a%'", "abc:1\naaa:0\n",
			"didn't get correct data back from execute");

	my $report;
	db_assert(
			$report = $testds->execute("
				insert test2
				values ('xxx', 1)
				;
				insert test2
				values ('xyz', 0)
				;
			", report => "(%R rows affected)\n"),
			"execute with report failed"
	);
	die("execute insert report wasn't correct: ". $report)
			unless $report eq "(1 rows affected)\n" x 2;

	db_assert(
			$report = $testds->execute("
				select * from test2
				where a like 'x%'
				;
				select * from test2
				where a like 'a%'
				;
			", report => "(%R rows affected)\n"),
			"execute with select and report failed"
	);
	die("execute select report wasn't correct: ". $report)
			unless $report eq "(4 rows affected)\n(2 rows affected)\n";

	db_assert(
			$report = $testds->execute("
				insert test2
				values ('ccc', 0)
				;
				select * from test2
				where a like 'a%'
				;
				drop table test2
				;
			", report => "%R rows\n"),
			"execute with mixed insert/select/drop and report failed"
	);
	die("execute mixed report wasn't correct: ". $report)
			unless $report eq "1 rows\n2 rows\n";

	print STDERR "about to check for test2 existence\n" if DEBUG >= 5;
	die("test2 table still exists after drop: ", $testds->last_error())
			# this ought to fail because the table should have been dropped
			if defined $testds->do("select * from test2");
}

sub test_vars
{
	$testds->define_var("a_val", "con");
	test_output("select * from test1 where a = {a_val}",
			"con:Jan  1 1753 12:00AM:0\ncon:Dec 31 9999 12:00AM:0\n",
			"variable set to 'con' didn't work");
	$testds->define_var("a_val", "xxx");
	test_output("select * from test1 where a = {a_val}",
			"xxx:Jan  1 2002 12:00AM:48.35\n" x (NUM_TEST_ROWS * 2),
			"variable set to 'xxx' didn't work");
}

sub test_conditionals
{
	$testds->define_var("a_val", "con");
	test_output("
				select * from test1
				where a = {a_val}				{?a_val}
			", 
			"con:Jan  1 1753 12:00AM:0\ncon:Dec 31 9999 12:00AM:0\n",
			"positive conditional didn't work");
	test_output("
				select * from test1
				where a ='{a_val}
				and b = {BEGINNING_OF_TIME}		{!a_val}
			", 
			"con:Jan  1 1753 12:00AM:0\ncon:Dec 31 9999 12:00AM:0\n",
			"negative conditional didn't work");
}

sub test_load_append_replace
{
	my $contents = $testds->load_table("
			select * from {~dbo}.test1
			where a = 'con'
			order by b
	");
	die("load_table returned undefined results") unless $contents;
	$contents->dump_set(*STDERR) if DEBUG >= 3;
	die("contents aren't correct")
			unless $contents->[0]->{a} eq 'con'
			and $contents->[1]->{a} eq 'con'
			and $contents->[0]->{b} eq 'Jan  1 1753 12:00AM'
			and $contents->[1]->{b} eq 'Dec 31 9999 12:00AM'
			and $contents->[0]->{c} == 0
			and $contents->[1]->{c} == 0;

	print STDERR "contents has ", scalar(@$contents), " rows\n" if DEBUG >= 3;
	$_->{c} = 1 foreach @$contents;
	print STDERR "finished changing contents\n" if DEBUG >= 5;
	die("call to append table failed")
			unless $testds->append_table("{~dbo}.test1", $contents);
	test_output("
				select * from {~dbo}.test1
				where a = 'con'
				order by c, b
			", 
			"con:Jan  1 1753 12:00AM:0\ncon:Dec 31 9999 12:00AM:0\n"
				. "con:Jan  1 1753 12:00AM:1\ncon:Dec 31 9999 12:00AM:1\n",
			"append table didn't work");

	die("call to replace table failed")
			unless $testds->replace_table("{~dbo}.test1", $contents);
	test_output("select * from {~dbo}.test1 order by b",
			"con:Jan  1 1753 12:00AM:1\ncon:Dec 31 9999 12:00AM:1\n",
			"append table didn't work");
}

sub test_show_queries
{
	my $query = "select * from test1";
	my $testfile = "test.query";
	$testds->show_queries();
	open(QRY, ">$testfile") or die("can't open output file for test query");
	select QRY;
	$testds->do($query);
	close(QRY);
	die("show queries didn't work")
			unless `cat $testfile` eq "DataStore current query:\n$query\n";
	$testds->show_queries(false);
	unlink($testfile);
	$testds->do($query);
	die("show queries didn't turn off") if -e $testfile;
	select STDOUT;
}

sub test_transactions
{
	$testds->begin_tran() or die("begin tran failed");
	$testds->do("insert into test1 values ('trn', '1/1/01', 0)")
			or die("insert for transaction failed");
	$testds->rollback() or die("rollback tran failed");
	test_output("select * from test1 where a = 'trn'",
			"", "rollback didn't work");

	$testds->begin_tran() or die("begin tran failed");
	$testds->do("insert into test1 values ('trn', '1/1/01', 0)")
			or die("insert for transaction failed");
	$testds->commit() or die("commit tran failed");
	test_output("select * from test1 where a = 'trn'",
			"trn:Jan  1 2001 12:00AM:0\n",
			"commit didn't work");
}

sub test_calc_columns
{
	my $res;
	db_assert($res = $testds->do("select {*fred = 1 + 2}"),
			"can't execute calc column query");
	$res->next_row();
	die("couldn't get correct output for calc column")
			unless $res->col(0) == 3;
	test_output("select {*fred = 1 + 2}", "3\n",
			"simplest calc column didn't work");
	test_output("
				select payroll_amount, overhead_amount,
					{*overhead_pct
						= range::round(%overhead_amount / %payroll_amount * 100,
								range::ROUND_OFF, .01)
					}
				from t3.{~timer}.payroll
				where check_date between '1/1/01' and '1/31/01'
			", 
			"11331.63:1294.74:11.43\n9603.26:1099.13:11.45\n",
			"can't reference columns in calcs"
	);
	test_output("
				select payroll_amount,
					{*running = \$total_amt += %payroll_amount}
				from t3.{~timer}.payroll
				where check_date between '1/1/01' and '1/31/01'
			", 
			"11331.63:11331.63\n9603.26:20934.89\n",
			"can't reference external vars in calcs"
	);
	die("running total failed")
			unless $testds->_transform_query("{total_amt}") eq "20934.89";
}
