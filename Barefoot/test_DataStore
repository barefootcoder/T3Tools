#! /usr/bin/perl

use strict;
use warnings;

use Barefoot::debug(1);

use Carp;
use Date::Format;

use Barefoot::base;
use Barefoot::range;
use Barefoot::exception;
use Barefoot::DataStore;
use Barefoot::DataStore::procs;

sub test_error(&@);


# alert to testing user
my $server = "kimahri";
my $testdb = "test";
my $rootuser = "root";
my $rdbms = "mysql";
print "\nNOTICE: This script requires a certain amount of setup.\n";
print "Make sure the following things are true if you have problems:\n";
print "    1) The server $server is up and running.\n";
print "    2) You have the $rootuser password in your .dbpasswd file.\n";
print "    3) The database '$testdb' exists.\n";
print "    4) The user 'buddy' a valid user in $testdb.\n";
print "    5) The user 'guest' is a valid user in $testdb.\n\n";

# test failure to find data store
test_error
{
	my $dsfail = DataStore->open("bogus");
}
catch { /data store bogus not found/ }
or die("bogus data store didn't throw not found error");

# test weird I/O errors by faking a data store file
test_error
{
	open(DS, ">fake.dstore") and close(DS);
	my $dsfail = DataStore->open("fake");
}
catch { /read error opening data store/ }
or die("fake data store didn't cause weird I/O error");
unlink("fake.dstore");


# test creating a new data store
my $newds = DataStore->create("new", user => "nobody");
die("didn't get a blank data store") unless $newds;
die("not blessed ref (DataStore)") unless $newds->isa("DataStore");

# print STDERR "calling dtor via undef\n";
undef $newds;
die("didn't create data store file upon destruction") unless -e "new.dstore";

# test to make sure open() requires a user
test_error
{
	$newds = DataStore->open("new");
}
catch { /must specify user/ }
or die("open didn't require user");

$newds = DataStore->open("new", "nobody");
die("couldn't retrieve newly created data store") unless $newds;
# print STDERR "newds is a ", ref $newds, "\n";
die("not blessed ref (DataStore)") unless $newds->isa("DataStore");


# make sure it doesn't save unless it's been modified
unlink("new.dstore");
# print STDERR "calling dtor via undef\n";
undef $newds;
die("saved data store spec w/o being modified") if -e "new.dstore";


# check to make sure create() catches bogus attributes
test_error
{
	my $bogusds = DataStore->create("bogus_attrib", bogus => "bogus");
}
catch { /can't create data store with unknown attribute bogus/ }
or die("create didn't notice bogus attribute");
die("created file with bogus attribute") if -e "bogus_attrib.dstore";


# make sure a bogus user bombs
test_error
{
	my $testds = DataStore->create("test",
		connect_string		=>	"dbi:$rdbms:server=$server",
		server				=>	$server,
		user				=>	"bogus",
	);
}
catch { /can't get db password/ }
or die("didn't detect bogus user");


# make sure a bogus database bombs
test_error
{
	print STDERR "BOGUS ERROR (if any) => ";
	my $testds = DataStore->create("test",
		connect_string		=>	"dbi:$rdbms:server=$server;database=bogus",
		server				=>	$server,
		user				=>	$rootuser,
	);
}
catch { /can't connect to data store as user/ }
or die("didn't detect bogus database");
print STDERR "\n";


# now let's create a datastore we can play with
use constant TEST_DS_FILE => "test.dstore";
my $testds = DataStore->create("test",
		connect_string		=>	"dbi:$rdbms:server=$server;database=$testdb",
		server				=>	$server,
		user				=>	$rootuser,
		translation_type	=>	$rdbms,
);

# check file creation after committing config changes
unlink(TEST_DS_FILE);
$testds->commit_configs();
die("didn't create data store after commit configs") unless -e TEST_DS_FILE;

# can we ping?
die("can't ping data store") unless $testds->ping();

# can we get one row?
my %rdbms_query =
(
	Sybase	=>	q{
					select name, crdate
					from sysobjects
					where name = 'sysobjects'
				},
	mysql	=>	qq{
					select user, host
					from mysql.user
					where user = 'root'
					and host = 'localhost'
				},
);
my $results = $testds->do($rdbms_query{$rdbms});
die("got no results (query 1)") unless $results;
die("results aren't blessed properly") unless $results->isa("DataStore::ResultSet");
$results->next_row();
die("incorrect number of columns") unless $results->num_cols() == 2;
if ($rdbms eq 'Sybase')
{
	die("results are not correct")
			unless $results->col("name") eq "sysobjects" and $results->col("crdate") eq "Jan  1 1900 12:00AM";
}
elsif ($rdbms eq 'mysql')
{
	die("results are not correct") unless $results->col("user") eq "root" and $results->col("host") eq "localhost";
}
else
{
	die("don't know what results are supposed to be!");
}

# what happens if you ask for an invalid column?
test_error
{
	my $x = $results->col("bogus");
}
catch { /unknown column name bogus/ }
or die("didn't catch illegal column name");

# can we get more than one row?
%rdbms_query =
(
	Sybase	=>	q{
					select name
					from sysobjects
					where name like 'sysc%'
				},
	mysql	=>	qq{
					select host
					from mysql.user
					where user = 'root'
					order by host
				},
);
$results = $testds->do($rdbms_query{$rdbms});
die("got no results (query 2)") unless $results;
die("incorrect number of columns") unless $results->num_cols() == 1;
my %correct_results =
(
	Sybase	=>	[ qw<syscolumns syscomments sysconstraints> ],
	mysql	=>	[ sort("localhost", $server) ],
);
my $count = 0;
while ($results->next_row())
{
	print STDERR "row ", $count + 1, " value :", $results->col(0), ":\n" if DEBUG >= 4;
	die("row " . ($count + 1) . " has incorrect value")
			unless $results->col(0) eq $correct_results{$rdbms}->[$count];
	++$count;
}


# make sure we can create tables
die("didn't gracefully handle illegal table name")
		if $testds->overwrite_table("%", [ ['a', 'char(1)', 'null'] ]);

die("can't create table: " . $testds->last_error())
		unless $testds->overwrite_table("test1", [
				[ 'a', 'char(3)', 'not null' ],
				[ 'b', 'date', 'null' ],
				[ 'c', 'money', 'null' ],
		]);

# and put data in ...
use constant NUM_TEST_ROWS => 15;
my $insquery = "insert into test1 values ('xxx', '2002/1/1', 48.35)\n";
$results = $testds->do($insquery) for 1..NUM_TEST_ROWS;
die("can't insert values properly: " . $testds->last_error()) unless $results;
$results = $testds->do("insert test1 select * from test1");
die("can't insert select properly: " . $testds->last_error()) unless $results;
my $nrows = $results->rows_affected();
die("didn't get proper number of rows (got $nrows)") unless $nrows == NUM_TEST_ROWS;

# ... and get data back out
$results = $testds->do("select * from test1");
die("can't get resultset colnames") unless join(':', $results->colnames()) eq 'a:b:c';
$count = 0;
my %date_result =
(
	Sybase	=>	'Jan  1 2002 12:00AM',
	mysql	=>	'2002-01-01',
);
while (my $row = $results->next_row())
{
	++$count;
	die("column 0 bad for row $count") unless $results->col(0) eq 'xxx';
	die("bad name for column 0") unless $results->colname(0) eq 'a';
	# print STDERR $results->col(1), "\n";
	die("column 1 bad for row $count")
			unless $results->col(1) eq $date_result{$rdbms};
	die("bad name for column 1") unless $results->colname(1) eq 'b';
	die("column 2 bad for row $count") unless $results->col(2) == 48.35;
	die("bad name for column 2") unless $results->colname(2) eq 'c';
	die("can't get row colnames")
			unless join(':', $row->colnames()) eq 'a:b:c';
}
die("didn't get proper number of rows back")
		unless $count == NUM_TEST_ROWS * 2;

my %date_constants =
(
	Sybase	=>	{
					begin	=>	'Jan  1 1753 12:00AM',
					end		=>	'Dec 31 9999 12:00AM',
				},
	mysql	=>	{
					begin	=>	'1000-01-01',
					end		=>	'9999-12-31',
				},
);

test_aliases();
test_constants();
test_bogus_function();
test_indices();
test_count_func();
test_misc_functions();
test_user_types();
test_schema_trans();
test_execute();
test_vars();
test_calc_columns();
test_col_attrs();

# make sure we're not using dbpasswd any more
print STDERR "path is $ENV{PATH}\n" if DEBUG >= 5;
$ENV{PATH} =~ s@/usr/local/dbutils:@@;

# make sure we can reopen our data store
undef $testds;
print STDERR "about to reopen test data store\n" if DEBUG >= 5;
$testds = DataStore->open("test", "buddy");
print STDERR "modified state is $testds->{modified}\n" if DEBUG >= 4;

# quick output check
test_output("select * from test1 where a = 'xxx'",
		"xxx:$date_result{$rdbms}:48.35\n" x (NUM_TEST_ROWS * 2),
		"can't get good data on reopen");

# for following tests, we need some permissions
$testds = DataStore->open("test", $rootuser);

test_load_append_replace();
test_show_queries();
test_transactions();
test_nonscalar_placeholders();
test_update_or_insert();

# clean up our test stuff
$testds = DataStore->open("test", $rootuser);	# have to be sa for this to work
db_assert($testds->do("drop table test1"), "can't drop test table");
db_assert($testds->do("drop table {~buddy}.test1"), "can't drop test table");
db_assert($testds->do("drop table {~guest}.test1"), "can't drop test table");
# if we don't do the below, running the test script enough times will
# eventually fill up the transaction log and then we're hosed
if ($rdbms eq 'Sybase')
{
	db_assert($testds->do("dump tran $testdb with no_log"), "can't dump tran");
}
unlink(TEST_DS_FILE);

# looks okay
unlink "new.dstore";
print "ALL TESTS PASSED\n";


################
# SUBS
################


sub db_assert
{
	my ($condition, $die_msg) = @_;

	die("$die_msg: " . $testds->last_error()) unless $condition;
}


sub test_error (&@)
{
	my ($try, $catch) = @_;

	# print STDERR "in test_error block\n";
	eval { &$try };
	if ($@)
	{
		# print "in try: $@";
		$@ =~ /^(.*) at (.*) line (\d+)(?:.*\.)?\n$/;
		die("incorrect 'die' format: $@") unless $3;
		local $_ = $1;
		print STDERR "actually caught $_\n" if DEBUG >= 2;
		$__FILE__ = $2;
		$__LINE__ = $3;
		return true if &$catch;
	}
	return false;
}


sub test_output
{
	my ($query, $expected_output, $die_msg) = @_;

	# print STDERR "about to do $query\n";
	my $res = $testds->do($query);
	croak("test_output query failed: " . $testds->last_error())
			unless defined $res;
	my $output = "";
	$output .= join(':', $res->all_cols()) . "\n" while $res->next_row();
	print STDERR "got output $output\n" if DEBUG >= 2;
	croak($die_msg) unless $output eq $expected_output;
}


sub test_aliases
{
	# make an alias for our test table
	$testds->configure_alias('t1' => 'test1');
	$testds->commit_configs();

	# check output from alias; should be same as test1 table
	test_output(q<select * from {@t1} where a = 'xxx'>,
			"xxx:$date_result{$rdbms}:48.35\n" x (NUM_TEST_ROWS * 2),
			"select from alias failed");
	
	# now try a bogus alias
	test_error
	{
		$testds->do('select * from {@bogus}');
	}
	catch { /unknown alias: bogus/ }
	or die("didn't detect bogus alias");
}


sub test_constants
{
	db_assert($testds->do("insert test1 values ('con', {BEGINNING_OF_TIME}, 1.01)"), "beginning of time insert failed");
	db_assert($testds->do("insert test1 values ('con', {END_OF_TIME}, 1.01)"), "end of time insert failed");
	test_output("select * from test1 where a = 'con'",
			"con:$date_constants{$rdbms}->{'begin'}:1.01\ncon:$date_constants{$rdbms}->{'end'}:1.01\n",
			"incorrect data stored for constants");
}

sub test_bogus_function
{
	test_error
	{
		$testds->do("{&bogus}");
	}
	catch { /unknown translation function: bogus/ }
	or die("didn't detect bogus function");
}

sub test_user_types
{
	# now make some user defined types
	$testds->configure_type('logical', 'boolean');

	# while we're here, make sure we can't call do() with config's pending
	test_error
	{
		$testds->do("something");
	}
	catch { /can't execute query with config's pending; run commit_configs()/ }
	or die("didn't refuse query with pending config's");

	# now make sure our defined type works
	$testds->commit_configs();
	die("can't create table with user types: " . $testds->last_error())
			unless $testds->overwrite_table("test2", [
					[ 'a', 'char(3)', 'not null' ],
					[ 'b', 'logical', 'null' ],
			]);
}

sub test_indices
{
	# first try to make an index
	db_assert($testds->do("create index t1 on test1 (a) {&place_on 'default'}"),
			"can't create an index (function place_on)");

	# now try to drop it
	db_assert($testds->do("{&drop_index test1, t1}"),
			"can't drop an index (function drop_index");
}

sub test_count_func
{
	# make sure NULL result returns undef
	die("null result count() does not return undef") if defined $testds->do(q{select null from test1 where 1 = 0})->count();

	# make sure when we no rows returns zero
	my $count = $testds->do(q{select count(*) from test1 where 1 = 0})->count();
	die("no rows count() does not return zero") unless defined $count and $count == 0;

	# and now make sure we get right number of rows
	$count = $testds->do(q{select count(*) from test1 where a = 'xxx'})->count();
	print STDERR "expected 30, got $count\n" if DEBUG >= 2;
	die("count() does not return proper number") unless defined $count and $count == 30;
}

sub test_misc_functions
{
	my %date_format =
	(
		Sybase	=>	'%b %e %Y',
		mysql	=>	'%Y-%m-%d',
	);

	# curdate function
	my $res = $testds->do("select {&curdate}");
	croak("curdate query failed:", $testds->last_error())
			unless defined $res and $res->next_row();
	# note: if you happen to be running this at the exact moment of midnight,
	# I suppose it's technically possible for the RDBMS date and the Unix
	# date to fail to match.  just run it again.
	print STDERR "current date: from data store = ", substr($res->col(0), 0, 11),
			", from Perl = ", time2str($date_format{$rdbms}, time()), "\n" if DEBUG >= 2;
	die("can't get current date") unless substr($res->col(0), 0, 11) eq time2str($date_format{$rdbms}, time());

	# ifnull function
	db_assert($testds->do(q{ insert test1 values ('nul', null, 123.45) }), "couldn't insert data1 to test ifnull func");
	db_assert($testds->do(q{ insert test1 values ('nul', null, null) }), "couldn't insert data2 to test ifnull func");
	db_assert($testds->do(q{ insert test1 values ('nul', null, 99.99) }), "couldn't insert data3 to test ifnull func");
	test_output("select {&ifnull c, 99.99} from test1 where a = 'nul' order by c", "99.99\n99.99\n123.45\n",
			"test of ifnull func failed");
}

sub test_schema_trans
{
	my %schema_trans =
	(
		Sybase	=>	q{ return "$_[0]."; },
		mysql	=>	q{ return "$_[0]_"; },
	);

	# define a schema translation
	$testds->configure_schema_translation($schema_trans{$rdbms});
	$testds->commit_configs();
	$testds->overwrite_table('{~guest}.test1', [['a', 'int', 'null']])
			or die("can't create initial table for schema testing");
	db_assert(
			$testds->overwrite_table('{~buddy}.test1', [['a', 'int', 'null']]),
			"can't create same table in different schema: "
	);
}

sub test_execute
{
	db_assert(
			$testds->execute("
				insert test2
				values ('xxx', 1)
				;
				insert test2
				values ('xyz', 0)
				;
			"),
			"basic execute failed"
	);
	test_output("select * from test2 where a like 'x%'", "xxx:1\nxyz:0\n",
			"didn't get correct data back from execute");

	db_assert(
			$testds->execute("
				insert test2
				values ('abc', 1)
				bmoogle		
				insert test2
				values ('aaa', 0)
				bmoogle      
			", delim => "bmoogle"),
			"execute with alternate delimiter failed"
	);
	test_output("select * from test2 where a like 'a%'", "abc:1\naaa:0\n",
			"didn't get correct data back from execute");

	my $report;
	db_assert(
			$report = $testds->execute("
				insert test2
				values ('xxx', 1)
				;
				insert test2
				values ('xyz', 0)
				;
			", report => "(%R rows affected)\n"),
			"execute with report failed"
	);
	die("execute insert report wasn't correct: ". $report)
			unless $report eq "(1 rows affected)\n" x 2;

	db_assert(
			$report = $testds->execute("
				select * from test2
				where a like 'x%'
				;
				select * from test2
				where a like 'a%'
				;
			", report => "(%R rows affected)\n"),
			"execute with select and report failed"
	);
	die("execute select report wasn't correct: ". $report)
			unless $report eq "(4 rows affected)\n(2 rows affected)\n";

	db_assert(
			$report = $testds->execute("
				insert test2
				values ('ccc', 0)
				;
				select * from test2
				where a like 'a%'
				;
				drop table test2
				;
			", report => "%R rows\n"),
			"execute with mixed insert/select/drop and report failed"
	);
	die("execute mixed report wasn't correct: " . $report)
			unless $report =~ /^1 rows\n2 rows\n(0E0 rows\n)?/;

	print STDERR "about to check for test2 existence\n" if DEBUG >= 5;
	die("test2 table still exists after drop: ", $testds->last_error())
			# this ought to fail because the table should have been dropped
			if defined $testds->do("select * from test2");
}

sub test_vars
{
	$testds->define_var("a_val", "con");
	test_output("select * from test1 where a = {a_val}",
			"con:$date_constants{$rdbms}->{'begin'}:1.01\ncon:$date_constants{$rdbms}->{'end'}:1.01\n",
			"variable set to 'con' didn't work");
	$testds->define_var("a_val", "xxx");
	test_output("select * from test1 where a = {a_val}",
			"xxx:$date_result{$rdbms}:48.35\n" x (NUM_TEST_ROWS * 2),
			"variable set to 'xxx' didn't work");

	# now test temporary, or override, vars
	$testds->do("insert test1 values
					( {a_val}, '$date_result{$rdbms}', {c_val} )",
				a_val => 'var', c_val => 96.55)
			or die("can't insert for temp var test");
	test_output("select * from test1 where a = 'var'",
			"var:$date_result{$rdbms}:96.55\n",
			"override vars don't work");
}

sub test_conditionals
{
	$testds->define_var("a_val", "con");
	test_output("
				select * from test1
				where a = {a_val}				{?a_val}
			", 
			"con:$date_constants{$rdbms}->{'begin'}:1.01\ncon:$date_constants{$rdbms}->{'end'}:1.01\n",
			"positive conditional didn't work");
	test_output("
				select * from test1
				where a ='{a_val}
				and b = {BEGINNING_OF_TIME}		{!a_val}
			", 
			"con:$date_constants{$rdbms}->{'begin'}:1.01\ncon:$date_constants{$rdbms}->{'end'}:1.01\n",
			"negative conditional didn't work");
}

sub test_load_append_replace
{
	my $contents = $testds->load_data("
			select * from test1
			where a = 'con'
			order by b
	");
	die("load_data returned undefined results") unless $contents;
	die("can't get dataset colnames")
				unless join(':', $contents->colnames()) eq 'a:b:c';
	$contents->dump_set(*STDERR) if DEBUG >= 3;
	die("contents aren't correct")
			unless $contents->[0]->{a} eq 'con'
			and $contents->[1]->{a} eq 'con'
			and $contents->[0]->{b} eq $date_constants{$rdbms}->{'begin'}
			and $contents->[1]->{b} eq $date_constants{$rdbms}->{'end'}
			and $contents->[0]->{c} == 1.01
			and $contents->[1]->{c} == 1.01;

	# make sure load_data can accept temp variables
	$contents = $testds->load_data('
			select * from test1
			where a = {a}
			order by b
	', a => 'con');
	die("load_data returned undefined results") unless $contents;
	die("can't get dataset colnames")
				unless join(':', $contents->colnames()) eq 'a:b:c';
	$contents->dump_set(*STDERR) if DEBUG >= 3;
	die("contents aren't correct")
			unless $contents->[0]->{a} eq 'con'
			and $contents->[1]->{a} eq 'con'
			and $contents->[0]->{b} eq $date_constants{$rdbms}->{'begin'}
			and $contents->[1]->{b} eq $date_constants{$rdbms}->{'end'}
			and $contents->[0]->{c} == 1.01
			and $contents->[1]->{c} == 1.01;

	# make sure load_table is the exact same as load_data
	$contents = $testds->load_table("
			select * from test1
			where a = 'con'
			order by b
	");
	die("load_table returned undefined results") unless $contents;
	die("can't get dataset colnames")
				unless join(':', $contents->colnames()) eq 'a:b:c';
	$contents->dump_set(*STDERR) if DEBUG >= 3;
	die("contents aren't correct")
			unless $contents->[0]->{a} eq 'con'
			and $contents->[1]->{a} eq 'con'
			and $contents->[0]->{b} eq $date_constants{$rdbms}->{'begin'}
			and $contents->[1]->{b} eq $date_constants{$rdbms}->{'end'}
			and $contents->[0]->{c} == 1.01
			and $contents->[1]->{c} == 1.01;

	print STDERR "contents has ", scalar(@$contents), " rows\n" if DEBUG >= 3;
	$_->{c} = 2.02 foreach @$contents;
	print STDERR "finished changing contents\n" if DEBUG >= 5;
	die("call to append table failed")
			unless $testds->append_table("test1", $contents);
	test_output("
				select * from test1
				where a = 'con'
				order by c, b
			", 
			"con:$date_constants{$rdbms}->{'begin'}:1.01\ncon:$date_constants{$rdbms}->{'end'}:1.01\n"
				. "con:$date_constants{$rdbms}->{'begin'}:2.02\ncon:$date_constants{$rdbms}->{'end'}:2.02\n",
			"append table didn't work");

	die("call to replace table failed")
			unless $testds->replace_table("test1", $contents);
	test_output("select * from test1 order by b",
			"con:$date_constants{$rdbms}->{'begin'}:2.02\ncon:$date_constants{$rdbms}->{'end'}:2.02\n",
			"append table didn't work");
}

sub test_show_queries
{
	my $query = "select * from test1";
	my $testfile = "test.query";
	$testds->show_queries();
	open(QRY, ">$testfile") or die("can't open output file for test query");
	select QRY;
	$testds->do($query);
	close(QRY);
	die("show queries didn't work")
			unless `cat $testfile` =~ /DataStore current query:\n(\s+cached version of\n)?\Q$query\E\n/;
	$testds->show_queries(false);
	unlink($testfile);
	$testds->do($query);
	die("show queries didn't turn off") if -e $testfile;
	select STDOUT;
}

sub test_transactions
{
	$testds->begin_tran() or die("begin tran failed");
	$testds->do("insert into test1 values ('trn', '1/1/01', 0)") or die("insert for transaction failed");
	$testds->rollback() or die("rollback tran failed");
	test_output("select * from test1 where a = 'trn'", "", "rollback didn't work");

	$testds->begin_tran() or die("begin tran failed");
	$testds->do("insert into test1 values ('trn', '$date_result{$rdbms}', 3.03)") or die("insert for transaction failed");
	$testds->commit() or die("commit tran failed");
	test_output("select * from test1 where a = 'trn'",
			"trn:$date_result{$rdbms}:3.03\n",
			"commit didn't work");
}

sub test_calc_columns
{
	my $res;
	db_assert($res = $testds->do("select {*fred = 1 + 2}"), "can't execute calc column query");
	$res->next_row();
	die("couldn't get correct output for calc column")
			unless $res->col(0) == 3;
	test_output("select {*fred = 1 + 2}", "3\n",
			"simplest calc column didn't work");
=comment
	test_output("
				select payroll_amount, overhead_amount,
					{*overhead_pct
						= range::round(%overhead_amount / %payroll_amount * 100,
								range::ROUND_OFF, .01)
					}
				from t3.{~timer}.payroll
				where check_date between '1/1/01' and '1/31/01'
			", 
			"11331.63:1294.74:11.43\n9603.26:1099.13:11.45\n",
			"can't reference columns in calcs"
	);
	test_output("
				select payroll_amount,
					{*running = \$total_amt += %payroll_amount}
				from t3.{~timer}.payroll
				where check_date between '1/1/01' and '1/31/01'
			", 
			"11331.63:11331.63\n9603.26:20934.89\n",
			"can't reference external vars in calcs"
	);
	die("running total failed")
			unless $testds->_transform_query("{total_amt}") eq "20934.89";
=cut
}

sub test_col_attrs
{
	# test IDENTITY attribute
	die("can't create table with identity: " . $testds->last_error())
			unless $testds->overwrite_table("test2", [
					[ 'a', 'int', 'identity' ],
					[ 'b', 'char(3)', 'null' ],
			]);
	die("can't create table with IDENTITY: " . $testds->last_error())
			unless $testds->overwrite_table("test2", [
					[ 'a', 'int', 'IDENTITY' ],
					[ 'b', 'char(3)', 'NULL' ],
			]);
	test_error
	{
		$testds->overwrite_table("test2", [
				[ 'a', 'int', 'identity' ],
				[ 'b', 'char(3)', 'null' ],
				[ 'c', 'int', 'identity' ],
		]);
	}
	catch { /can't have multiple IDENTITY columns/ }
	or die("didn't detect multiple identity cols");

	# make sure IDENTITY is doing what's it's supposed to be doing
	db_assert($testds->do(q{ insert test2 (b) values ('aaa') }), "identity insert failed") for 1..3;
	test_output(q{ select a from test2 },
			"1\n2\n3\n",
			"identity column not functioning");
}


sub test_values
{
	my ($which_test, @test_rows) = @_;

	my $data = $testds->load_data("select a, b, c from test1 where a = '$which_test' order by c");
	print STDERR "got error: ", $testds->last_error(), "\n" if not defined $data and DEBUG >= 2;
	return undef unless $data;

	my $real_data = join("\n", map { join("||", @$_) } @$data);
	my $test_data = join("\n", map { join("||", @$_) } @test_rows);
	print STDERR "real data is >>>\n$real_data\n<<<\n" if DEBUG >= 3;
	print STDERR "test data is >>>\n$test_data\n<<<\n" if DEBUG >= 4;
	return $real_data eq $test_data;
}


sub test_nonscalar_placeholders
{
	my $res = $testds->do('insert into test1 values ???', { a => 'INS', b => '2001/1/1', c => 63.87 });
	die("insert failed: " . $testds->last_error()) unless $res and $res->rows_affected() == 1;
	die("insert gave wrong data") unless test_values("INS", [ 'INS', '2001-01-01', '63.87' ]);

	my $today = time2str("%Y-%m-%d", time());	# hopefully we don't cross a midnight boundary between this line and the next
	$res = $testds->do('insert into test1 values ???', { a => 'IN2', b => '{&curdate}', c => 100.05 });
	die("2nd insert failed: " . $testds->last_error()) unless $res and $res->rows_affected() == 1;
	die("2nd insert gave wrong data") unless test_values("IN2", [ 'IN2', $today, '100.05' ]);

	#my @rows_to_insert = ( { c => 123, a => 'INX', b => '2002-01-01' }, { c => 456, a => 'INX', b => '2002-01-01' },
	#		{ c => 789, a => 'INX', b => '2002-01-01' } );
	#$res = $testds->do('insert into test1 values ???', @rows_to_insert);
	#die("multiple insert failed: " . $testds->last_error()) unless $res;
	#die("multiple insert gave wrong data")
	#		unless test_values("INX", map { [ @$_{qw<a b c>} ] } @rows_to_insert);

	$res = $testds->do(q{ update test1 set ??? where a = 'INS' }, { a => 'UPD', c => 55.43 });
	die("update failed: " . $testds->last_error()) unless $res and $res->rows_affected() == 1;
	die("update gave wrong data") unless test_values("UPD", [ 'UPD', '2001-01-01', '55.43' ]);

	$res = $testds->do(q{ update test1 set ??? where a = 'UPD' }, { a => 'UP2', b => '{&curdate}' });
	die("update failed: " . $testds->last_error()) unless $res and $res->rows_affected() == 1;
	die("update gave wrong data") unless test_values("UP2", [ 'UP2', $today, '55.43' ]);
}


sub test_update_or_insert
{
	# get count of rows before starting
	my $test1_rows = $testds->do(q{ select count(*) from test1 })->count();

	# this one should insert
	my $res = $testds->update_or_insert(test1 => q{ where a = 'U|I' }, { a => 'U|I', b => '1999/12/31', c => 99 });
	die("upd_or_ins insert failed: " . $testds->last_error()) unless $res and $res->rows_affected() == 1;
	die("upd_or_ins gave wrong data") unless test_values("U|I", [ 'U|I', '1999-12-31', '99.00' ]);
	die("test1 row count screwy") unless $testds->do(q{ select count(*) from test1 })->count() == $test1_rows + 1;

	# and this one should update
	$res = $testds->update_or_insert(test1 => q{ where a = 'U|I' }, { a => 'U|I', b => '2001/1/1', c => 101 });
	die("upd_or_ins update failed: " . $testds->last_error()) unless $res and $res->rows_affected() == 1;
	die("upd_or_ins gave wrong data") unless test_values("U|I", [ 'U|I', '2001-01-01', '101.00' ]);
	die("test1 row count screwy") unless $testds->do(q{ select count(*) from test1 })->count() == $test1_rows + 1;

	# this updates too, only with variables
	$res = $testds->update_or_insert(test1 => q{ where a = {a} }, { a => 'U|I', c => 199 });
	die("upd_or_ins 2nd update failed: " . $testds->last_error()) unless $res and $res->rows_affected() == 1;
	die("upd_or_ins gave wrong data") unless test_values("U|I", [ 'U|I', '2001-01-01', '199.00' ]);
	die("test1 row count screwy") unless $testds->do(q{ select count(*) from test1 })->count() == $test1_rows + 1;

	# now let's ditch that and try again with stamps
	$res = $testds->do(q{ delete from test1 where a = 'U|I' });
	die("can't reset upd_or_ins testing") unless $res and $res->rows_affected() == 1
			and $testds->do(q{ select count(*) from test1 })->count() == $test1_rows;

	test_error
	{
		$testds->update_or_insert_set_stamps(bogus => {c => 9 });
	}
	catch { /unknown trigger/ }
	or die("didn't detect bogus trigger for upd_or_ins stamps");
	$testds->update_or_insert_set_stamps(insert => { c => 0 }, update => { c => 1 });

	# insert
	$res = $testds->update_or_insert(test1 => q{ where a = 'U|I' }, { a => 'U|I', b => '1999/12/31' });
	die("upd_or_ins insert failed: " . $testds->last_error()) unless $res and $res->rows_affected() == 1;
	die("upd_or_ins gave wrong data") unless test_values("U|I", [ 'U|I', '1999-12-31', '0.00' ]);
	die("test1 row count screwy") unless $testds->do(q{ select count(*) from test1 })->count() == $test1_rows + 1;

	# and update
	$res = $testds->update_or_insert(test1 => q{ where a = 'U|I' }, { a => 'U|I', b => '2001/1/1' });
	die("upd_or_ins update failed: " . $testds->last_error()) unless $res and $res->rows_affected() == 1;
	die("upd_or_ins gave wrong data") unless test_values("U|I", [ 'U|I', '2001-01-01', '1.00' ]);
	die("test1 row count screwy") unless $testds->do(q{ select count(*) from test1 })->count() == $test1_rows + 1;
}
