#! /usr/bin/perl

# For RCS:
# $Date$
# $Log$
# Revision 1.1  1999/02/23 22:50:00  buddy
# Initial revision
#
# $Id$
# $Revision$

use strict;

use Env qw(TIMERDIR HOME USER);
use Getopt::Std;

use Barefoot::timerdata;

#################################
# CONSTANTS
#################################

*timefile = \'timer.$$$';
*histfile = \'timer.history';
*timelog = \'p:\\proj\\timer\\timelog.exe';

*sambagrp = \'guestpc';

# constants for round()
*OFF	= \1;
*UP		= \2;
*DOWN	= \3;

#################################
# FORMATS
#################################

*Elapsed =
	\'@<< @<<<<<<<<<<<<<<<<<  for @<<  at  @> hrs @> mins  (@>>>>>>>>>)   @<<<<<<<<<<';

#################################
# OPTIONS AND ENVIRONMENT VARS
#################################

if (@ARGV == 0)
{
	error(0,
		"incorrect usage; usage is:\n",
		"    timer -{s|p|d|c|e|r|b} [-fh] [-u user] [-C clientnum] ",
						"[timername] [newtimername]\n",
		"       -s:   start a timer\n",
		"       -p:   pause all timers\n",
		"       -d:   done with a timer\n",
		"       -c:   cancel a timer\n",
		"       -n:   new name for a timer\n",
		"       -e:   show elapsed time for all timers\n",
		"       -r:   run the FoxPro TIMELOG program\n",
		"       -b:   break down a timer's portions\n",
		"       -f:   force (ignore all confirmations)\n",
		"       -h:   half-time timing (while watching movies, etc)\n",
		#"       -l:   leave existing timer running (when starting new one)\n",
		"       -u:   user name to use (default is current user)\n",
		"       -C:   client number to use (default is user-specific)\n",
		"    user must have an I:\\ drive directory\n",
		"    clientnum must be a valid 3-digit timer code\n",
		"    timername is ignored for -p\n",
		"    newtimername is ignored for all but -n\n",
	);
}

my $timerinfo = {};

my $opt = {};
getopts('sedrcpnbfhlu:C:$:', $opt);
$timerinfo->{force} = defined($opt->{f});
$timerinfo->{halftime} = defined($opt->{h});
$timerinfo->{leavecurrent} = defined($opt->{l});
$timerinfo->{user} = $opt->{u};
$timerinfo->{client} = $opt->{C};

$timerinfo->{tdir} = defined($::TIMERDIR) ? $::TIMERDIR : $::HOME;
if (!$timerinfo->{user})
{
	$timerinfo->{user} = $::USER;
}
elsif ($timerinfo->{user} ne $::USER)
{
	$timerinfo->{tdir} =~ s/$::USER/$timerinfo->{user}/;
}
$timerinfo->{tfile} = "$timerinfo->{tdir}/$::timefile";
$timerinfo->{hfile} = "$timerinfo->{tdir}/$::histfile";
$timerinfo->{giventimer} = $ARGV[0] ? $ARGV[0] : "default";
$timerinfo->{newname} = $ARGV[1];
$timerinfo->{timers} = {};
my $func = "";
my $fopt;
foreach $fopt ( ('s','e','d','r','c','p','n','b') )
{
	$func .= $fopt if $opt->{$fopt};
}

#################################
# CHECK FOR ERRORS
#################################

if (!$timerinfo->{tdir})
{
	error(2, "don't have a directory for timer files\n");
}
if (! -d $timerinfo->{tdir} or ! -w $timerinfo->{tdir})
{
	error(2, "no writeable directory $timerinfo->{tdir} for user $timerinfo->{user}\n");
}
if (!$timerinfo->{user})
{
	error(2, "can't figure out which user to timer for\n");
}

if (length($func) != 1)
{
	error(2, "you must specify exactly one function (s,e,d,r,c,p,n,b)\n");
}

if ($timerinfo->{halftime} and $func != 's')
{
	error(2, "half-time flag only makes sense when starting a timer\n");
}



#################################
# main()
#################################

readfile($timerinfo);

if ($func eq 'e')					# show elapsed time
{
	if ($timerinfo->{curtimer} eq 0)
	{
		error(1, "not timing for user $timerinfo->{user}\n");
	}
	print_elapsed($timerinfo);
}

if ($func eq 's')					# start a timer
{
	if (!$timerinfo->{force})
	{
		print_elapsed($timerinfo);
		get_giventimer("start", $timerinfo);
	}

	if ($timerinfo->{giventimer} eq $timerinfo->{curtimer})
	{
		error(1, "already timing for $timerinfo->{curtimer}\n");
	}
	$timerinfo->{timers}->{$timerinfo->{curtimer}}->{time} .= time . ','
			if $timerinfo->{curtimer} and not $timerinfo->{leavecurrent};
	$timerinfo->{timers}->{$timerinfo->{giventimer}}->{time} .=
			($timerinfo->{halftime} ? "2/" : "") . time . '-';
	$timerinfo->{timers}->{$timerinfo->{giventimer}}->{client}
			= get_client($func, $timerinfo);
	$timerinfo->{curtimer} = $timerinfo->{giventimer};

	print_elapsed($timerinfo);
	writefile($timerinfo);
}

if ($func eq 'p')					# pause all timers
{
	if (!$timerinfo->{curtimer})
	{
		error(1, "no timer is actively timing\n");
	}

	if (!$timerinfo->{force})
	{
		print_elapsed($timerinfo);
		print STDERR "are you sure you want to pause all timers?  (y/N) ";
		exit unless <STDIN> =~ /^y/i;
	}

	$timerinfo->{timers}->{$timerinfo->{curtimer}}->{time} .= time . ',';
	delete $timerinfo->{curtimer};

	print_elapsed($timerinfo);
	writefile($timerinfo);
}

if ($func eq 'c')					# cancel a timer
{
	if (!$timerinfo->{force})
	{
		print_elapsed($timerinfo);
		get_giventimer("cancel", $timerinfo);

		print STDERR "warning! a cancelled timer is gone forever!\n";
		print STDERR "are you sure you want to cancel timer ",
				$timerinfo->{giventimer}, "?  (y/N) ";
		exit unless <STDIN> =~ /^y/i;
	}

	if (!exists $timerinfo->{timers}->{$timerinfo->{giventimer}})
	{
		error(1, "can't cancel; no such timer\n");
	}

	delete $timerinfo->{timers}->{$timerinfo->{giventimer}};
	delete $timerinfo->{curtimer}
			if $timerinfo->{curtimer} eq $timerinfo->{giventimer};

	print_elapsed($timerinfo);
	writefile($timerinfo);
}

if ($func eq 'n')					# new name for a timer
{
	if (!$timerinfo->{force})
	{
		print_elapsed($timerinfo);
		get_giventimer("new name for", $timerinfo);
	}

	# just a shortcut here
	my $oldname = $timerinfo->{giventimer};

	if (!exists $timerinfo->{timers}->{$oldname})
	{
		error(1, "can't rename; no such timer\n");
	}

	my $newname;
	if ($timerinfo->{newname} and $timerinfo->{force})
	{
		$newname = $timerinfo->{newname};
	}
	else
	{
		my $defname = $timerinfo->{newname} ? $timerinfo->{newname} : $oldname;
		print STDERR "new name for this timer? ($defname)  ";
		$newname = <STDIN>;
		chomp $newname;
		$newname = $defname if not $newname;
	}

	# if we're renaming ...
	if ($newname ne $oldname)
	{
		if (exists $timerinfo->{timers}->{$newname})
		{
			error(1, "that timer already exists\n");
		}

		$timerinfo->{timers}->{$newname} = $timerinfo->{timers}->{$oldname};
		delete $timerinfo->{timers}->{$oldname};
		# got to do this so get_client() (below) will work
		$timerinfo->{giventimer} = $newname;
	}

	# but of course we might just be changing the client
	$timerinfo->{timers}->{$newname}->{client} = get_client($func, $timerinfo);

	$timerinfo->{curtimer} = $newname if $timerinfo->{curtimer} eq $oldname;
	print_elapsed($timerinfo);
	writefile($timerinfo);
}

if ($func eq 'b')
{
	if (!$timerinfo->{force})
	{
		print_elapsed($timerinfo);
		get_giventimer("break down", $timerinfo);
	}

	my @parts = split(/,/,
			$timerinfo->{timers}->{$timerinfo->{giventimer}}->{time});
	my $part;
	foreach $part (@parts)
	{
		my $mins = calc_time($part);

		if ($part =~ /^([+-]\d+)$/)
		{
			print "adjusted time by $1 minutes ($mins mins)\n";
			next;
		}

		$part =~ m{(?:(\d+)/)?(\d+)-(\d+)?};
		my ($min, $hr, $day, $mon, $year) = (localtime $2)[1..5];
		++$mon, $year += 1900;
		print "from $hr:$min $mon/$day/$year ";
		if ($3)
		{
			($min, $hr, $day, $mon, $year) = (localtime $3)[1..5];
			++$mon, $year += 1900;
			print "to $hr:$min $mon/$day/$year";
		}
		else
		{
			print "to current (still timing)";
		}
		print " at half-time" if $1 == 2;
		print " ($mins mins)\n";
	}
}

if ($func eq 'r')					# run the FoxPro program (TIMELOG)
{
	if (! -x $::timelog)
	{
		error(1, "can't run the timelog program (are you in Linux?)\n");
	}

	print "running the FoxPro timelog program ...\n";
	exec $::timelog, $timerinfo->{user};
	die "couldn't execute timelog: $!";
}

if ($func eq 'd')					# done with a timer; run TIMELOG
{
	if (! -x $::timelog)
	{
		error(1, "can't run the timelog program (are you in Linux?)\n");
	}

	if (!$timerinfo->{force})
	{
		print_elapsed($timerinfo);
		get_giventimer("done with", $timerinfo);
	}

	if (!exists $timerinfo->{timers}->{$timerinfo->{giventimer}})
	{
		error(1, "no such timer as $timerinfo->{giventimer}\n");
	}

	my $thistimer = $timerinfo->{timers}->{$timerinfo->{giventimer}};
	my $minutes = calc_time($thistimer->{time});
	my $hours = round($minutes / 60, $::DOWN),
	my $date = calc_date($thistimer);
	my $client = $thistimer->{client};
	print "total time is $minutes mins ($hours hrs ", $minutes - $hours * 60,
		" mins) on $date for $client\n";
	print "please remember this in case TIMELOG has a problem!\n";
	if (!$timerinfo->{force})
	{
		print "press return to continue ...\n";
		<STDIN>;
	}

	save_history($timerinfo, "done");
	delete $timerinfo->{timers}->{$timerinfo->{giventimer}};
	writefile($timerinfo);

	print "\nrunning the FoxPro timelog program ...\n";
	exec $::timelog, $timerinfo->{user}, "D", $minutes, $date, $client;
	die "couldn't execute timelog: $!";
}


#################################
# SUBROUTINES
#################################

sub error
{
	my ($exitcode, @messages) = @_;
	my $progname = $0;
	$progname =~ s?.*/??;
	print STDERR "$progname: ", @messages;
	exit $exitcode;
}

sub readfile
{
	my ($timerinfo) = @_;

	open(TFILE, $timerinfo->{tfile}) or return 0;
	while ( <TFILE> )
	{
		my ($key, $time, $client) = split;
		my $curtimer = {};
		$curtimer->{time} = $time;
		$curtimer->{client} = $client;
		$timerinfo->{timers}->{$key} = $curtimer;
		$timerinfo->{curtimer} = $key if ($time =~ /-$/);
	}
	close(TFILE);
}

sub writefile
{
	my ($timerinfo) = @_;

	open(TFILE, ">$timerinfo->{tfile}") or die "can't open timer file";
	my $timer;
	foreach $timer (keys %{$timerinfo->{timers}})
	{
		my $timerstuff = $timerinfo->{timers}->{$timer};
		print TFILE $timer, "\t", $timerstuff->{time}, "\t",
				$timerstuff->{client}, "\n";
	}
	close(TFILE);

	# if these don't work, no big deal, but if running under Linux, they
	# should reset the file to be accessible from 4DOS/Win95
	eval { chown -1, scalar(getgrnam($::sambagrp)), $timerinfo->{tfile} };
	eval { chmod 0660, $timerinfo->{tfile} };
}

sub save_history
{
	my ($timerinfo, $func) = @_;
	my $timerstuff = $timerinfo->{timers}->{$timerinfo->{giventimer}};

	open(HIST, ">>$timerinfo->{hfile}") or die("couldn't open history file");
	print HIST "$timerinfo->{user}\t$func\t$timerinfo->{giventimer}\t",
			"$timerstuff->{time}\t$timerstuff->{client}\n";
	close(HIST);
}

sub get_giventimer
{
	my ($function, $timerinfo) = @_;

	{
		print "$function what timer? ($timerinfo->{giventimer})  ";
		my $new = <STDIN>;
		chomp $new;
		if ($new =~ /\s/)
		{
			print STDERR "timer name can't have a space; sorry\n";
			redo;
		}
		$timerinfo->{giventimer} = $new if $new;
	}
}

sub get_client
{
	my ($func, $timerinfo) = @_;
	# a little shortcut here
	my $giventimer = $timerinfo->{timers}->{$timerinfo->{giventimer}};

	# this is somewhat complicated ...  we need to figure out what the
	# proper client should be, and then use it as the default ... now,
	# we have three possible places to get the potential client from:
	# the default client for this user (out of Sybase), the client
	# already set for a pre-existing timer, or the client specified on
	# the command line (if given) ... for starting a timer, the priority
	# is: pre-existing, command line, default ... for renaming a timer,
	# the priority is command line, pre-existing, default ... now! if -f
	# (force) was specified, we can quit right here ... also, if we're
	# _start_ing a pre-existing timer, the user isn't allowed to change
	# the client, so we quit in that case too ...

	# got it? here we go ...
	my $defclient;
	if ($func ne 'n')							# anything but new name
	{											# (probably start)
		if (exists $giventimer->{client})		# pre-existing client first
		{
			$defclient = $giventimer->{client};
		}
		elsif ($timerinfo->{client})			# then -C option
		{
			$defclient = $timerinfo->{client};
		}
		else									# defclient from Sybase
		{
			$defclient = timerdata::default_client($timerinfo->{user});
		}
	}
	else										# must be new name
	{
		if ($timerinfo->{client})				# -C option first
		{
			$defclient = $timerinfo->{client};
		}
		elsif (exists $giventimer->{client})	# then pre-existing client
		{
			$defclient = $giventimer->{client};
		}
		else									# defclient from Sybase
		{
			$defclient = timerdata::default_client($timerinfo->{user});
		}
	}
	return $defclient if $timerinfo->{force}
			or ($func eq 's' and exists $giventimer->{client});

	my $client;
	# make a(n unnamed) block so redo will work
	{
		print "which client is this for? ($defclient)  ";
		$client = <STDIN>;
		chomp $client;
		$client = $defclient if not $client;	# use default if not specified
		my $fullname = timerdata::client_name($client);
		if (defined($fullname))
		{
			print "illegal client number!\n" and redo if not $fullname;
			print "client is $client: $fullname; is this right? (y/N)  ";
		}
		else
		{
			print "can't verify client number! are you sure you want to ",
					"proceed? (y/N)  ";
		}
		redo unless <STDIN> =~ /^y/i;
	}
	return $client;
}

sub print_elapsed
{
	my ($timerinfo) = @_;

	print "\nTIMERS FOR $timerinfo->{user}:\n";
	my $timer;
	foreach $timer (keys %{$timerinfo->{timers}})
	{
		my $minutes = calc_time($timerinfo->{timers}->{$timer}->{time});
		my $hours = round($minutes / 60, $::DOWN);
		$minutes = $minutes - $hours * 60;
		my $date = calc_date($timerinfo->{timers}->{$timer}->{time});

		writeln($::Elapsed, $timerinfo->{curtimer} eq $timer ? "==>" : "",
				$timer, $timerinfo->{timers}->{$timer}->{client},
				$hours, $minutes, $date,
				$timerinfo->{timers}->{$timer}->{time} =~ m{/\d+-$}
					? "HALF-TIMING" : "");
	}
	print $timerinfo->{curtimer} ? "active timer is $timerinfo->{curtimer}"
			: "no timer is active";
	print "\n\n";
}

sub calc_time
{
	my ($line) = @_;
	my @times = split(/,/, $line);
	my $total_time = 0;

	my $current_time = 0;
	my $time;
	foreach $time (@times)
	{
		if ($time =~ /^([+-]\d+)$/)
		{
			$total_time += $1 * 60;
			next;
		}

		my ($divisor, $from, $to) = $time =~ m{(?:(\d+)/)?(\d+)-(\d+)?};
		die "illegal format in time file" unless $from;
		if (!$to)
		{
			die "more than one current time in time file" if $current_time;
			$current_time = 1;
			$to = time;
		}
		$total_time += ($to - $from) / ($divisor ? $divisor : 1);
	}
	return round($total_time / 60, $::UP);
}

sub calc_date
{
	my ($line) = @_;

	my $seconds;
	if ($line =~ /(\d+),$/)		# ends in a comma, must be paused
	{
		$seconds = $1;
	}
	else						# must be current
	{
		$seconds = time;
	}
	my ($day, $mon, $year) = (localtime $seconds)[3..5];
	return ++$mon . "/" . $day . "/" . ($year + 1900);
}

sub round
{
	my ($what, $whichway, $towhat) = @_;
	$whichway = $::OFF if !$whichway;
	$towhat = 1 if !$towhat;

	$what /= $towhat;
	if ($what =~ /\.(\d)/)
	{
		$what = int $what;
		++$what if $whichway == $::UP;
		++$what if $whichway == $::OFF && $1 >= 5;
	}
	return $what * $towhat;
}

sub writeln
{
	my ($format, @vars) = @_;
	$^A = "";
	formline($format, @vars);
	print $^A, "\n";
}
