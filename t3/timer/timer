#! /usr/bin/perl

# For RCS:
# $Date: 2003/03/25 23:37:52 $
#
# $Id: timer,v 1.38 2003/03/25 23:37:52 buddy Exp $
# $Revision: 1.38 $

use strict;
use warnings;

use Barefoot::debug;

use CGI;
use Getopt::Std;
use Data::Dumper;

use Barefoot::base;
use Barefoot::date;
use Barefoot::range;
use Barefoot::format;
use Barefoot::exception;
use Barefoot::input qw<get_yn input>;
use Barefoot::T3Timer qw<get_timer_info do_timer_command>;

use Barefoot::T3::base;
use Barefoot::T3::valid qw<get_parameter>;
use Barefoot::T3::db_get qw<client_rounding proj_requirements>;
use Barefoot::T3::Timer qw<calc_date calc_time test_connection
		this_week_totals>;


#################################
# CONSTANTS
#################################


#################################
# FORMATS
#################################

use constant Elapsed =>
	'@<< @<<<<<<<<<<<<<<<<<  for @<<,@<<@<<<<< at @> hrs @> mins (@>>>>>>>>>) @<<<';

use constant Totals =>
	'@<< @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  $@##.##  total: @##.## hours';
use constant Totals_No_Rates =>
	'@<< @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<           total: @##.## hours';

use constant Log =>
	'
	Employee:  @<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<         Date:
	Client:    @<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<         @<<<<<<<<<
	Project:   @<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<         Hours:
	Phase:     @<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<         @##.##

	  Client Tracking Code: @<<<<<<<<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

	Comments:';
use constant Log_Comments =>
	'      ~~^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<';

BEGIN { print STDERR "passed all use's\n" if DEBUG >= 5; }


#################################
# OPTIONS AND ENVIRONMENT VARS
#################################

print STDERR "about to begin execution\n" if DEBUG >= 5;

our $parminfo = {};
our $timers = {};
my $command_strings = {
	s	=>	"START",
	e	=>	"LIST",
	d	=>	"DONE",
	l	=>	"LOG",
	c	=>	"CANCEL",
	p	=>	"PAUSE",
	r	=>	"RENAME",
	b	=>	"BREAKDOWN",
	t	=>	"TOTAL",
	'@'	=>	"PARSE",
};
our ($cgi, $command, $workgroup);

if (-t STDOUT or @ARGV)
{
	usage() if @ARGV == 0;

	my $opt = {};
	getopts('sedlcprbtfhu:C:P:H:@:', $opt) or usage();
	$parminfo->{force} = defined $opt->{f};
	$parminfo->{noconfirm} = defined $opt->{f};
	$parminfo->{halftime} = defined $opt->{h};
	$parminfo->{user} = $opt->{u};
	$parminfo->{client} = $opt->{C};
	$parminfo->{project} = string::upper($opt->{P});
	$parminfo->{phase} = string::upper($opt->{H});
	$parminfo->{parse_fmt} = $opt->{'@'};

	$parminfo->{newtimer} = $ARGV[1];

	foreach my $copt ( qw<s e d l c p r b t @> )
	{
		if (exists $opt->{$copt})
		{
			error(2, "you must specify exactly one command (s,e,d,l,c,p,r,b)")
					if defined $command;
			$command = $command_strings->{$copt};
			# print STDERR "defined command as $command\n";
		}
	}
}
else
{
	$cgi = new CGI;
	$workgroup = $cgi->param('workgroup');
	$parminfo->{user} = $cgi->param('user');
	$parminfo->{client} = $cgi->param('client');
	$parminfo->{timer} = $cgi->param('timername');
	$parminfo->{newtimer} = $cgi->param('newname');

	$parminfo->{force} = 1;					# no input when run as a CGI
	$parminfo->{parse_fmt} = 'x';				# always output XML-style

	$command = $command_strings->{string::left($cgi->param('mode'), 1)};

	# get a header out there so the server won't choke
	print $cgi->header('text/plain');
}


#################################
# CHECK FOR ERRORS
#################################


usage() unless $command;

print STDERR "survived args and error checks\n" if DEBUG >= 5;


#################################
# main()
#################################


# get the basics for our $timers collection
try
{
	$timers = get_timer_info($ARGV[0], $parminfo);
}
catch
{
	error(3, $_);
};


if ($command eq 'START')					# start a timer
{
	# integration with TODO module
	if ($parminfo->{timer} =~ /^todo:(.*)$/)
	{
		my $todo_name = $1;

		# probably ought to be calling todo's readfile here,
		# but need to make vast improvements to readfile before we can do that
		open(TODO, T3::base_filename(TODO => $parminfo->{user}))
				or die("can't open todo file for $parminfo->{user}");
		my $todo = {};
		my $found = false;
		while ( <TODO> )
		{
			if ( /^$todo_name\t/ )
			{
				chomp;
				(todo_fields($todo)) = split("\t");
				$found = true;
				last;
			}
		}
		close(TODO);

		die("can't find todo name $todo_name") unless $found;

		$parminfo->{timer} = $todo_name;
		$parminfo->{client} = $todo->{client};
		$parminfo->{project} = $todo->{project};
		$parminfo->{todo_link} = $todo_name;
	}

	unless ($parminfo->{force})
	{
		print_elapsed($parminfo, $timers);
		get_giventimer("start", $parminfo);
	}

	if (not exists $timers->{$parminfo->{timer}})
	{
		if (test_connection())
		{
			print STDERR "given timer doesn't exist, getting new values\n"
					if DEBUG >= 5;
			get_timer_parameter("client");
			get_timer_parameter("project");

			my ($phase_needed) = proj_requirements($parminfo->{client},
					$parminfo->{project}, calc_date(time));

			get_timer_parameter("phase") if $phase_needed;
		}
		else
		{
			$parminfo->{client} = 0;
			$parminfo->{project} = 0;
			$parminfo->{phase} = 0;
		}
	}
}

if ($command eq 'PAUSE')					# pause all timers
{
	if (!$timers->{T3::CURRENT_TIMER})
	{
		error(1, "no timer is actively timing");
	}

	if (!$parminfo->{force})
	{
		print_elapsed($parminfo, $timers);
		exit unless get_yn("are you sure you want to pause all timers?");
	}
}

if ($command eq 'CANCEL')					# cancel a timer
{
	if (!$parminfo->{force})
	{
		print_elapsed($parminfo, $timers);
		get_giventimer("cancel", $parminfo);

		print STDERR "warning! a cancelled timer is gone forever!\n";
		print STDERR "are you sure you want to cancel timer ",
				$parminfo->{timer}, "?  (y/N) ";
		exit unless <STDIN> =~ /^y/i;
	}
}

if ($command eq 'RENAME')					# new name for a timer
{
	if (!$parminfo->{force})
	{
		print_elapsed($parminfo, $timers);
		get_giventimer("new name for", $parminfo);
	}

	if (not $parminfo->{newtimer} or not $parminfo->{force})
	{
		my $defname = $parminfo->{newtimer} || $parminfo->{timer};
		$parminfo->{newtimer} = input("new name for this timer?", $defname);
	}

	if (test_connection())
	{
		get_timer_parameter("client");
		get_timer_parameter("project");

		my ($phase_needed, $tracking_needed, $comments_needed) = 
				proj_requirements(
					$parminfo->{client}, $parminfo->{project},
					calc_date(time)
				);

		get_timer_parameter("phase") if $phase_needed;
	}
}

if ($command eq 'BREAKDOWN')					# break down a timer
{
	if (!$parminfo->{force})
	{
		print_elapsed($parminfo, $timers);
		get_giventimer("break down", $parminfo);
	}

	my $giventimer = $parminfo->{timer};
	if (not exists $timers->{$giventimer})
	{
		error(1, "no such timer as $giventimer");
	}

	my @parts = split(/,/, $timers->{$giventimer}->{time});
	foreach my $part (@parts)
	{
		my $mins = calc_time($part);

		if ($part =~ /^([+-]\d+)$/)
		{
			print "adjusted time by $1 minutes ($mins mins)\n";
			next;
		}

		$part =~ m{(?:(\d+)/)?(\d+)-(\d+)?};
		my $tmp = $1 ? $1 : 0;
		my ($min, $hr, $day, $mon, $year) = (localtime $2)[1..5];
		++$mon, $year += 1900;
		print "from $mon/$day/$year $hr:$min ";
		if ($3)
		{
			($min, $hr, $day, $mon, $year) = (localtime $3)[1..5];
			++$mon, $year += 1900;
			print "to $mon/$day/$year $hr:$min";
		}
		else
		{
			print "to current (still timing)";
		}
		print " at half-time" if $tmp == 2;
		#print " at half-time" if $1 == 2;
		print " ($mins mins)\n";
	}

	# no need for anything further
	exit;
}

if ($command eq 'TOTAL')					# total timers by client
{
	print STDERR "about to start TOTAL routine\n" if DEBUG >= 5;

	unless (test_connection())
	{
		print STDERR "The data store is not accessible. Action canceled.\n";
		exit;
	}

	# get totals for this weeks timers
	my ($totals, $bad_proj) = this_week_totals($parminfo->{user}, $timers);
	error(4, "can't get totals out of database") unless defined $totals;
	error(4, "can't get bad project rows") unless defined $bad_proj;

	my $grand_total = 0;
	foreach my $error (@$bad_proj)
	{
		my ($client, $hours) = @$error;

		writeln(Totals_No_Rates, $client, "ERROR! Invalid project", $hours);
		$grand_total += $hours;
	}
	foreach my $total (@$totals)
	{
		my ($client, $client_name, $rate, $hours) = @$total;

		if (not defined $rate)
		{
			writeln(Totals_No_Rates, $client,
					"ERROR! No rate defined", $hours);
		}
		else
		{
			writeln(Totals, $client, $client_name, $rate, $hours);
		}
		$grand_total += $hours;
	}

	# print total totals
	print "=" x length(Totals), "\n";
	writeln(Totals_No_Rates, "", "Grand Total", $grand_total);

	# all done
	exit;
}

if ($command eq 'LOG')					# log time directly to the DB
{
	unless (test_connection())
	{
		print STDERR "The data store is not accessible. Action canceled.\n";
		exit;
	}
	
	gather_log_info();
}

if ($command eq 'DONE')					# done with a timer
{
	unless (test_connection())
	{
		print STDERR "The data store is not accessible. Action canceled.\n";
		exit;
	}
	
	if (!$parminfo->{force})
	{
		print_elapsed($parminfo, $timers);
		get_giventimer("done with", $parminfo);
	}

	my $giventimer = $parminfo->{timer};
	if (!exists $timers->{$giventimer})
	{
		error(1, "no such timer as $giventimer");
	}

	my $thistimer = $timers->{$giventimer};
	my $minutes = calc_time($thistimer->{time});
	my $hours = range::round($minutes / 60, range::ROUND_DOWN),
	my $date = calc_date($thistimer->{time});
	my $client = $thistimer->{client};
	print "\ntotal time is $minutes mins ($hours hrs ", $minutes - $hours * 60,
		" mins) on $date for $client\n";
	print "please remember this in case there is a problem!\n\n";
	if (!$parminfo->{force})
	{
		print "press return to continue ...\n";
		<STDIN>;
	}

	gather_log_info($giventimer);
}

if ($command eq 'PARSE')			# special flag for use by other processes
{
	print_parsable($parminfo, $timers);
	exit;
}

try
{
	# the main event
	do_timer_command($command, $parminfo, $timers);
}
catch
{
	error(3, $_);
};

unless ( $command eq 'LOG' )
{
	print_elapsed($parminfo, $timers);
}


#################################
# SUBROUTINES
#################################

sub usage
{
	error(0,
		"incorrect usage; usage is:\n",
		"    timer -{s|p|d|c|r|e|l|b|t} [-fh] [-u user] [-C clientnum] ",
						"[-P projcode] [timername [newtimername]] ",
						"[-H phasecode]\n",
		"       -s:   start a timer\n",
		"       -p:   pause all timers\n",
		"       -d:   done with a timer\n",
		"       -c:   cancel a timer\n",
		"       -r:   rename/change info for a timer\n",
		"       -e:   show elapsed time for all timers\n",
		"       -l:   log time directly to database\n",
		"       -b:   break down a timer's portions\n",
		"       -t:   total for all timers this week (by client)\n",
		"       -f:   force (ignore all confirmations)\n",
		"       -h:   half-time timing (while watching movies, etc)\n",
		"       -u:   user name to use (default is current user)\n",
		"       -C:   client number to use (default is user-specific)\n",
		"       -P:   project code to use (no default)\n",
		"       -H:   phase code to use (no default)\n",
		"    clientnum must be a valid 3-digit code\n",
		"    projcode and phasecode must be a valid 3-character code ",
				"\n	(will be forced to uppercase)\n",
		"    timername is ignored for -p, -e, -l, and -t\n",
		"    newtimername is ignored for all but -r\n",
	);
}


sub error
{
	my ($exitcode, @messages) = @_;
	my $progname = $0;
	$progname =~ s@.*/@@;
	if ($cgi)
	{
		foreach (@messages)
		{
			# s/\n/<BR>\n/g;
		}
		print @messages, "\n";
		exit 0;
	}
	else
	{
		print STDERR "$progname: ", @messages, "\n";
		exit $exitcode;
	}
}


sub get_giventimer
{
	my ($function, $parminfo) = @_;

	TIMER: {
		my $new = input("$function what timer? ", $parminfo->{timer});
		if ($new =~ /\s/)
		{
			print STDERR "timer name can't have a space; sorry\n";
			redo TIMER;
		}
		elsif ($new =~ /^:/)
		{
			print STDERR "timer name can't start with a colon; sorry\n";
			redo TIMER;
		}

		$parminfo->{timer} = $new if $new;
	}
}


sub get_timer_parameter
{
	my ($parmname) = @_;
	print "wantarray is ", defined wantarray ? wantarray : "undef", "\n"
			if DEBUG >= 4;

	# objinfo would be the specified timer, which we get here
	my $objinfo = $timers->{$parminfo->{timer}};

	# this is somewhat complicated.  we need to figure out what the
	# proper thing (client, project, or phase) should be, and then use
	# it as the default.  now, we have three possible places to get this
	# info from: the default for this user (from the database; get_parameter
	# knows how to retrieve that), the thing already set (for a pre-existing
	# timer; this comes from objinfo), or the thing specified on the command
	# line (if specified at all; this comes from parminfo).  for most cases,
	# the priority is: command line, pre-existing, default.  for the start
	# command, however, a pre-existing parameter can't be changed if it
	# exists, so we use it and exit.	also, if -f (force) was specified
	# (that flag is in parminfo), we can quit right there.

	# got it? here we go ...

	my $opts = {};
	# this will keep people from being able to change parameters if the
	# command is "start"
	$opts->{RESTRICT_CHANGES} = true if $command eq 'START';

	return get_parameter($parmname, $parminfo, $objinfo, $opts);
}


sub print_elapsed
{
	my ($parminfo, $timers) = @_;
	print_parsable($parminfo, $timers) and return if $cgi;

	#print Dumper($timers);
	print "\nTIMERS FOR $parminfo->{user}:\n";
	while (my ($tname, $timer) = each %$timers)
	{
		# ignore tags
		next if substr($tname, 0, 1) eq ':';

		my $minutes = calc_time($timer->{time});
		my $hours = range::round($minutes / 60, range::ROUND_DOWN);
		$minutes = $minutes - $hours * 60;
		my $date = calc_date($timer->{time});
		my $curtimer_marker = $timers->{T3::CURRENT_TIMER} &&
				$timers->{T3::CURRENT_TIMER} eq $tname ? "==>" : "";

		writeln(Elapsed, $curtimer_marker, $tname, $timer->{client},
				$timer->{project}, $timer->{phase} ? ",$timer->{phase}" : "",
				$hours, $minutes, $date,
				$timer->{time} =~ m{/\d+-$} ? "HALF-TIMING" : "");
	}

	print $timers->{T3::CURRENT_TIMER}
			? "active timer is $timers->{T3::CURRENT_TIMER}"
			: "no timer is active";
	print "\n\n";
}

sub print_parsable
{
	my ($parminfo, $timers) = @_;

	my $user = $parminfo->{user};
	while (my ($tname, $timer) = each %$timers)
	{
		print "$tname\n" and next if $parminfo->{parse_fmt} eq 't';

		my $client = $timer->{client};
		foreach my $part (reverse split(/,/, $timer->{time}))
		{
			print "<TIMER>" if $parminfo->{parse_fmt} eq 'x';
			print "$user:$tname:$client:";

			my $mins = calc_time($part);
			print "$mins:";

			if ($part =~ /^([+-]\d+)$/)
			{
				# raw adjustment; date and time not known
				print ":";
				next;
			}

			my ($start, $end) = ($part =~ m{(?:(\d+)/)?(\d+)-(\d+)?});
			print "$start:$end";		# if current, $end will be blank field

			# not sure if half-time is needed, so we'll leave it out for now
			# print " at half-time" if $1 == 2;

			print "</TIMER>" if $parminfo->{parse_fmt} eq 'x';
			print "\n";
		}
	}
	return 1;
}


sub gather_log_info
{
	my ($log_timer) = @_;

	# For logging timers, we MUST ask for codes; no 'force' allowed.  But
	# the noconfirm option can still turn off the annoying confirmations.
	$parminfo->{force} = false;

	# a shortcut
	my $timer = defined $log_timer ? $timers->{$log_timer} : undef;
	print STDERR "$log_timer timer: ", Dumper($timer) if DEBUG >= 2;

	my ($emp_id, $emp_fullname, $client, $client_name, $rounding, $to_nearest,
			$date, $hours, $project, $project_name, $phase, $phase_name,
			$tracking, $tracking_name, $comments);

	# please note that the order you ask for the data elements in is
	# *very* important ... the following things are true:
	#	you have to do employee before you do client
	#	you have to do employee before you do project
	#	you have to do date before you do client
	#	you have to do date before you do project
	# 	you have to do client before you do hours
	#	you have to do client before you do project
	#	you have to do client before you do tracking
	#	you have to do project before you do phase
	#	you have to do project before you do tracking
	#	you have to do project before you do comments
	# based on this, there is not a whole lot you can do differently in
	# the order chosen below, so DON'T MUCK WITH IT!

	($emp_id, $emp_fullname) = get_timer_parameter("employee");
	
	# $parminfo->{user} may not match emp_id at this point; that's ok.
	# It lets us track the actual person who submitted the command.

	$parminfo->{date} = $date = input(
			"Date:",
			$timer ? calc_date($timer->{time}) : date::today(),
			{
				VALID		=>	\&date::isValid,
				VALID_ERR	=>	"  {Invalid date!}\n",
			}
	);


	# Get client info
	($client, $client_name) = get_timer_parameter("client");

	HOURS: {
		($rounding, $to_nearest) = client_rounding($client);

#print STDERR "$_ => $timer->{$_}\n" foreach keys %$timer;

		$hours = input("Hours:",
				$timer ? range::round(calc_time($timer->{time}) / 60,
						$rounding, $to_nearest) : 0);
		print "  {Hours must divisible by $to_nearest}\n" and redo HOURS
				unless $hours == range::round($hours,
					range::ROUND_OFF, $to_nearest);
		print "  {Hours must be greater than zero}\n" and redo HOURS
				unless $hours > 0;
	}
	$parminfo->{hours} = $hours;

	# Get project info
	($project, $project_name) = get_timer_parameter("project");

	my ($phase_needed, $tracking_needed, $comments_needed)
			= proj_requirements($client, $project, $date);

	# Get phase information
	($phase, $phase_name) = $phase_needed
			? get_timer_parameter("phase") : (undef, "");
	$parminfo->{phase} = $phase;

	($tracking, $tracking_name) = $tracking_needed ?
			get_timer_parameter("client tracking code") : (undef, "");
	$parminfo->{tracking} = $tracking;

	COMMENTS: {
		$comments = undef;
		last unless $comments_needed;
		print "\nEnter comments below (maximum 255 chars):\n";
		print "  (255 chars is a little over 3 lines if your screen is 80\n";
		print "   columns wide and you don't hit RETURN at all (which you ",
				"shouldn't))\n";
		print "Enter ^D (control-D) on a line by itself to finish the ",
				"comments.\n";
		local ($/) = undef;
		$comments = input();
		while ($comments =~ s/^\s+$//) {};	# no completely blank lines
		while ($comments =~ s/^\n//) {};	# no extra newlines in front
		$comments =~ s/\s*\n+\s*$//;		# none at the end either
		print "  {You must have comments}\n\n" and redo COMMENTS
				if not $comments;
		print "  {Comments too long!}\n\n" and redo COMMENTS
				if length($comments) > 255;
	}
	$parminfo->{comments} = $comments;

	print "working.....\n";

	# show everything and double check:
	writeln(Log,
			$emp_id,	$emp_fullname,
			$client,	$client_name,				$date,
			$project,	$project_name,
			$phase,		$phase_name,				$hours,
							$tracking, $tracking_name
	);
	writeln(Log_Comments, $comments);

	<STDIN>;
	unless (get_yn("\n\nis everything okay?"))
	{
		print "\n  {Try to log this timer out again later.}\n";
		exit 1;
	}

	print STDERR "parms after gather_log_info: ", Dumper($parminfo)
			if DEBUG >= 4;
}
