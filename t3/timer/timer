#! /usr/bin/perl

# For RCS:
# $Date$
# $Log$
# $Id$
# $Revision$

use strict;

use Env qw(TIMERDIR HOME USER);
use Getopt::Std;

#################################
# CONSTANTS
#################################

*timefile = \'timer.$$$';
*histfile = \'timer.history';
*timelog = \'p:\\proj\\timer\\timelog.exe';

*sambagrp = \'guestpc';

# constants for round()
*OFF	= \1;
*UP		= \2;
*DOWN	= \3;

#################################
# FORMATS
#################################

*Elapsed =
	\'@<< @<<<<<<<<<<<<<<<<<  at  @> hrs @> mins  (@>>>>>>>>>)   @<<<<<<<<<<';

#################################
# OPTIONS AND ENVIRONMENT VARS
#################################

if (@ARGV == 0)
{
	error(0,
		"incorrect usage; usage is:\n",
		"    timer -(s|p|d|c|e|r|b) [-fh] [-u user] [timername]\n",
		"       -s:   start a timer\n",
		"       -p:   pause all timers\n",
		"       -d:   done with a timer\n",
		"       -c:   cancel a timer\n",
		"       -n:   new name for a timer\n",
		"       -e:   show elapsed time for all timers\n",
		"       -r:   run the FoxPro TIMELOG program\n",
		"       -b:   break down a timer's portions\n",
		"       -f:   force (ignore all confirmations)\n",
		"       -h:   half-time timing (while watching movies, etc)\n",
		"       -u:   user name to use (default is current user)\n",
	);
}

my $timerinfo = {};

my $opt = {};
getopts('sedrcpnbfhu:$:', $opt);
$timerinfo->{force} = defined($opt->{f});
$timerinfo->{halftime} = defined($opt->{h});
$timerinfo->{user} = $opt->{u};

$timerinfo->{tdir} = defined($::TIMERDIR) ? $::TIMERDIR : $::HOME;
if (!$timerinfo->{user})
{
	$timerinfo->{user} = $::USER;
}
elsif ($timerinfo->{user} ne $::USER)
{
	$timerinfo->{tdir} =~ s/$::USER/$timerinfo->{user}/;
}
$timerinfo->{tfile} = "$timerinfo->{tdir}/$::timefile";
$timerinfo->{hfile} = "$timerinfo->{tdir}/$::histfile";
$timerinfo->{newtimer} = $ARGV[0] ? $ARGV[0] : "default";
$timerinfo->{timers} = {};
my $func = "";
my $fopt;
foreach $fopt ( ('s','e','d','r','c','p','n','b') )
{
	$func .= $fopt if $opt->{$fopt};
}

#################################
# CHECK FOR ERRORS
#################################

if (!$timerinfo->{tdir})
{
	error(2, "don't have a directory for timer files\n");
}
if (! -d $timerinfo->{tdir} or ! -w $timerinfo->{tdir})
{
	error(2, "no writeable directory $timerinfo->{tdir} for user $timerinfo->{user}\n");
}
if (!$timerinfo->{user})
{
	error(2, "can't figure out which user to timer for\n");
}

if (length($func) != 1)
{
	error(2, "you must specify exactly one function (s,e,d,r,c,p,n,b)\n");
}

if ($timerinfo->{halftime} and $func != 's')
{
	error(2, "half-time flag only makes sense when starting a timer\n");
}



#################################
# main()
#################################

readfile($timerinfo);

if ($func eq 'e')					# show elapsed time
{
	if ($timerinfo->{curtimer} eq 0)
	{
		error(1, "not timing for user $timerinfo->{user}\n");
	}
	print_elapsed($timerinfo);
}

if ($func eq 's')					# start a timer
{
	if (!$timerinfo->{force})
	{
		print_elapsed($timerinfo);
		get_newtimer("start", $timerinfo);
	}

	if ($timerinfo->{newtimer} eq $timerinfo->{curtimer})
	{
		error(1, "already timing for $timerinfo->{curtimer}\n");
	}
	$timerinfo->{timers}->{$timerinfo->{curtimer}} .= time . ','
			if $timerinfo->{curtimer};
	$timerinfo->{timers}->{$timerinfo->{newtimer}} .=
			($timerinfo->{halftime} ? "2/" : "") . time . '-';
	$timerinfo->{curtimer} = $timerinfo->{newtimer};

	print_elapsed($timerinfo);
	writefile($timerinfo);
}

if ($func eq 'p')					# pause all timers
{
	if (!$timerinfo->{curtimer})
	{
		error(1, "no timer is actively timing\n");
	}

	if (!$timerinfo->{force})
	{
		print_elapsed($timerinfo);
		print STDERR "are you sure you want to pause all timers?  (y/N) ";
		exit unless <STDIN> =~ /^y/i;
	}

	$timerinfo->{timers}->{$timerinfo->{curtimer}} .= time . ',';
	delete $timerinfo->{curtimer};

	print_elapsed($timerinfo);
	writefile($timerinfo);
}

if ($func eq 'c')					# cancel a timer
{
	if (!$timerinfo->{force})
	{
		print_elapsed($timerinfo);
		get_newtimer("cancel", $timerinfo);

		print STDERR "warning! a cancelled timer is gone forever!\n";
		print STDERR "are you sure you want to cancel timer ",
				$timerinfo->{newtimer}, "?  (y/N) ";
		exit unless <STDIN> =~ /^y/i;
	}

	if (!exists $timerinfo->{timers}->{$timerinfo->{newtimer}})
	{
		error(1, "can't cancel; no such timer\n");
	}

	delete $timerinfo->{timers}->{$timerinfo->{newtimer}};
	delete $timerinfo->{curtimer}
			if $timerinfo->{curtimer} eq $timerinfo->{newtimer};

	print_elapsed($timerinfo);
	writefile($timerinfo);
}

if ($func eq 'n')					# new name for a timer
{
	if (!$timerinfo->{force})
	{
		print_elapsed($timerinfo);
		get_newtimer("new name for", $timerinfo);
	}

	if (!exists $timerinfo->{timers}->{$timerinfo->{newtimer}})
	{
		error(1, "can't rename; no such timer\n");
	}

	print STDERR "new name for this timer? ";
	my $newname = <STDIN>;
	chomp $newname;

	if (exists $timerinfo->{timers}->{$newname})
	{
		error(1, "that timer already exists\n");
	}

	$timerinfo->{timers}->{$newname} =
			$timerinfo->{timers}->{$timerinfo->{newtimer}};
	delete $timerinfo->{timers}->{$timerinfo->{newtimer}};
	print_elapsed($timerinfo);
	writefile($timerinfo);
}

if ($func eq 'b')
{
	if (!$timerinfo->{force})
	{
		print_elapsed($timerinfo);
		get_newtimer("break down", $timerinfo);
	}

	my @parts = split(/,/, $timerinfo->{timers}->{$timerinfo->{newtimer}});
	my $part;
	foreach $part (@parts)
	{
		my $mins = calc_time($part);

		if ($part =~ /^([+-]\d+)$/)
		{
			print "adjusted time by $1 minutes ($mins mins)\n";
			next;
		}

		$part =~ m{(?:(\d+)/)?(\d+)-(\d+)?};
		my ($min, $hr, $day, $mon, $year) = (localtime $2)[1..5];
		++$mon, $year += 1900;
		print "from $hr:$min $mon/$day/$year ";
		if ($3)
		{
			($min, $hr, $day, $mon, $year) = (localtime $3)[1..5];
			++$mon, $year += 1900;
			print "to $hr:$min $mon/$day/$year";
		}
		else
		{
			print "to current (still timing)";
		}
		print " at half-time" if $1 == 2;
		print " ($mins mins)\n";
	}
}

if ($func eq 'r')					# run the FoxPro program (TIMELOG)
{
	if (! -x $::timelog)
	{
		error(1, "can't run the timelog program (are you in Linux?)\n");
	}

	print "running the FoxPro timelog program ...\n";
	exec $::timelog, $timerinfo->{user};
	die "couldn't execute timelog: $!";
}

if ($func eq 'd')					# done with a timer; run TIMELOG
{
	if (! -x $::timelog)
	{
		error(1, "can't run the timelog program (are you in Linux?)\n");
	}

	if (!$timerinfo->{force})
	{
		print_elapsed($timerinfo);
		get_newtimer("done with", $timerinfo);
	}

	if (!exists $timerinfo->{timers}->{$timerinfo->{newtimer}})
	{
		error(1, "no such timer as $timerinfo->{newtimer}\n");
	}

	my $thistimer = $timerinfo->{timers}->{$timerinfo->{newtimer}};
	my $minutes = calc_time($thistimer);
	my $hours = round($minutes / 60, $::DOWN),
	my $date = calc_date($thistimer);
	print "total time is $minutes mins ($hours hrs ", $minutes - $hours * 60,
		" mins) on $date\n";
	print "please remember this in case TIMELOG has a problem!\n";
	if (!$timerinfo->{force})
	{
		print "press return to continue ...\n";
		<STDIN>;
	}

	save_history($timerinfo, "done");
	delete $timerinfo->{timers}->{$timerinfo->{newtimer}};
	writefile($timerinfo);

	print "\nrunning the FoxPro timelog program ...\n";
	exec $::timelog, $timerinfo->{user}, "D", $minutes, $date;
	die "couldn't execute timelog: $!";
}


#################################
# SUBROUTINES
#################################

sub error
{
	my ($exitcode, @messages) = @_;
	my $progname = $0;
	$progname =~ s?.*/??;
	print STDERR "$progname: ", @messages;
	exit $exitcode;
}

sub readfile
{
	my ($timerinfo) = @_;

	open(TFILE, $timerinfo->{tfile}) or return 0;
	while ( <TFILE> )
	{
		my ($key, $value) = split;
		$timerinfo->{timers}->{$key} = $value;
		$timerinfo->{curtimer} = $key if ($value =~ /-$/);
	}
	close(TFILE);
}

sub writefile
{
	my ($timerinfo) = @_;

	open(TFILE, ">$timerinfo->{tfile}") or die "can't open timer file";
	my $timer;
	foreach $timer (keys %{$timerinfo->{timers}})
	{
		print TFILE $timer, "\t", $timerinfo->{timers}->{$timer}, "\n";
	}
	close(TFILE);

	# if these don't work, no big deal, but if running under Linux, they
	# should reset the file to be accessible from 4DOS/Win95
	eval { chown -1, scalar(getgrnam($::sambagrp)), $timerinfo->{tfile} };
	eval { chmod 0660, $timerinfo->{tfile} };
}

sub save_history
{
	my ($timerinfo, $func) = @_;

	open(HIST, ">>$timerinfo->{hfile}") or die("couldn't open history file");
	print HIST "$timerinfo->{user}\t$func\t",
			"$timerinfo->{timers}->{$timerinfo->{newtimer}}\n";
	close(HIST);
}

sub get_newtimer
{
	my ($function, $timerinfo) = @_;

	{
		print "$function what timer? ($timerinfo->{newtimer})  ";
		my $new = <STDIN>;
		chomp $new;
		if ($new =~ /\s/)
		{
			print STDERR "timer name can't have a space; sorry\n";
			redo;
		}
		$timerinfo->{newtimer} = $new if $new;
	}
}

sub print_elapsed
{
	my ($timerinfo) = @_;

	print "\nTIMERS FOR $timerinfo->{user}:\n";
	my $timer;
	foreach $timer (keys %{$timerinfo->{timers}})
	{
		my $minutes = calc_time($timerinfo->{timers}->{$timer});
		my $hours = round($minutes / 60, $::DOWN);
		$minutes = $minutes - $hours * 60;
		my $date = calc_date($timerinfo->{timers}->{$timer});

		writeln($::Elapsed, $timerinfo->{curtimer} eq $timer ? "==>" : "",
				$timer, $hours, $minutes, $date,
				$timerinfo->{timers}->{$timer} =~ m{/\d+-$}
					? "HALF-TIMING" : "");
	}
	print $timerinfo->{curtimer} ? "active timer is $timerinfo->{curtimer}"
			: "no timer is active";
	print "\n\n";
}

sub calc_time
{
	my ($line) = @_;
	my @times = split(/,/, $line);
	my $total_time = 0;

	my $current_time = 0;
	my $time;
	foreach $time (@times)
	{
		if ($time =~ /^([+-]\d+)$/)
		{
			$total_time += $1 * 60;
			next;
		}

		my ($divisor, $from, $to) = $time =~ m{(?:(\d+)/)?(\d+)-(\d+)?};
		die "illegal format in time file" unless $from;
		if (!$to)
		{
			die "more than one current time in time file" if $current_time;
			$current_time = 1;
			$to = time;
		}
		$total_time += ($to - $from) / ($divisor ? $divisor : 1);
	}
	return round($total_time / 60, $::UP);
}

sub calc_date
{
	my ($line) = @_;

	my $seconds;
	if ($line =~ /(\d+),$/)		# ends in a comma, must be paused
	{
		$seconds = $1;
	}
	else						# must be current
	{
		$seconds = time;
	}
	my ($day, $mon, $year) = (localtime $seconds)[3..5];
	return ++$mon . "/" . $day . "/" . ($year + 1900);
}

sub round
{
	my ($what, $whichway, $towhat) = @_;
	$whichway = $::OFF if !$whichway;
	$towhat = 1 if !$towhat;

	$what /= $towhat;
	if ($what =~ /\.(\d)/)
	{
		$what = int $what;
		++$what if $whichway == $::UP;
		++$what if $whichway == $::OFF && $1 >= 5;
	}
	return $what * $towhat;
}

sub writeln
{
	my ($format, @vars) = @_;
	$^A = "";
	formline($format, @vars);
	print $^A, "\n";
}
