#! /usr/bin/perl

# For RCS:
# $Date: 2003/03/25 23:37:52 $
#
# $Id: timer,v 1.38 2003/03/25 23:37:52 buddy Exp $
# $Revision: 1.38 $

use strict;
use warnings;

#use Barefoot::debug(1);

use CGI;
use Getopt::Std;
use Data::Dumper;
use File::HomeDir;
use Config::General;

use Barefoot::base;
use Barefoot::range;
use Barefoot::format;
use Barefoot::exception;
use Barefoot::input qw< get_yn input >;
use Barefoot::date epoch => '2003-12-29';
use Barefoot::T3Timer qw< get_timer_info do_timer_command >;

use Barefoot::T3::base;
use Barefoot::T3::valid qw <get_parameter >;
use Barefoot::T3::db_get qw< one_datum get_emp_id client_rounding proj_requirements get_logs >;
use Barefoot::T3::Timer qw <calc_date calc_time test_connection this_week_totals >;


#################################
# CONSTANTS
#################################


use constant RC_FILE => "$~{$ENV{'USER'}}/.t3rc";
my $RC = read_rc();


#################################
# FORMATS
#################################


use constant Elapsed =>
	'@<< @<<<<<<<<<<<<<<<<<  for @<<,@<<@<<<<< at @> hrs @> mins (@>>>>>>>>>) @<<<';


use constant Totals_Header =>
	'@<< @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<           total: @##.## hours';
use constant Totals =>
	'    @<< @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<       total: @##.## hours';


use constant Totals_Weekly =>
	'@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<               total: @##.## hours';
use constant Average_Weekly =>
	'AVERAGE WEEKLY TIME:                                @##.## hours';


use constant Log =>
	'
	Employee:  @<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<         Date:
	Client:    @<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<         @<<<<<<<<<
	Project:   @<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<         Hours:
	Phase:     @<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<         @##.##

	  Client Tracking Code: @<<<<<<<<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

	Comments:';
use constant Log_Comments =>
	'      ~~^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<';

BEGIN { print STDERR "passed all use's\n" if DEBUG >= 5; }


#################################
# OPTIONS AND ENVIRONMENT VARS
#################################

print STDERR "about to begin execution\n" if DEBUG >= 5;

our $parminfo = {};
our $timers = {};
my $command_strings = {
	s	=>	"START",
	e	=>	"LIST",
	d	=>	"DONE",
	l	=>	"LOG",
	c	=>	"CANCEL",
	p	=>	"PAUSE",
	r	=>	"RENAME",
	b	=>	"BREAKDOWN",
	t	=>	"TOTAL",
	L	=>	"LOGALL",
	i	=>	"COPYINFO",
	a	=>	"AVERAGE",
	'@'	=>	"PARSE",
};
our ($cgi, $command, $workgroup);

if (-t STDOUT or @ARGV)
{
	usage() if @ARGV == 0;

	my $opt = {};
	getopts('sedlcpribLtafhu:C:P:H:@:', $opt) or usage();
	$parminfo->{force} = defined $opt->{f};
	$parminfo->{noconfirm} = defined $opt->{f};
	$parminfo->{halftime} = defined $opt->{h};
	$parminfo->{user} = $opt->{u};
	$parminfo->{client} = string::upper($opt->{C});
	$parminfo->{project} = string::upper($opt->{P});
	$parminfo->{phase} = string::upper($opt->{H});
	$parminfo->{parse_fmt} = $opt->{'@'};

	$parminfo->{newtimer} = $ARGV[1];

	foreach my $copt ( qw <s e d l c i p r b L t a @ > )
	{
		if (exists $opt->{$copt})
		{
			error(2, "you must specify exactly one command (s,e,d,l,c,i,p,r,b,L,t,a)")
					if defined $command;
			$command = $command_strings->{$copt};
			# print STDERR "defined command as $command\n";
		}
	}
}
else
{
	$cgi = new CGI;
	$workgroup = $cgi->param('workgroup');
	$parminfo->{user} = $cgi->param('user');
	$parminfo->{client} = $cgi->param('client');
	$parminfo->{timer} = $cgi->param('timername');
	$parminfo->{newtimer} = $cgi->param('newname');

	$parminfo->{force} = 1;					# no input when run as a CGI
	$parminfo->{parse_fmt} = 'x';				# always output XML-style

	$command = $command_strings->{string::left($cgi->param('mode'), 1)};

	# get a header out there so the server won't choke
	print $cgi->header('text/plain');
}

$parminfo->{'backup_rotate'} = rc_param(ALL => 'BackupRotation');


#################################
# CHECK FOR ERRORS
#################################


usage() unless $command;

print STDERR "survived args and error checks\n" if DEBUG >= 5;


#################################
# main()
#################################


# get the basics for our $timers collection
try
{
	$timers = get_timer_info($ARGV[0], $parminfo);
}
catch
{
	error(3, $_);
};


if ($command eq 'START')					# start a timer
{
	# integration with TODO module
	if ($parminfo->{timer} =~ /^todo:(.*)$/)
	{
		my $todo_name = $1;

		# probably ought to be calling todo's readfile here,
		# but need to make vast improvements to readfile before we can do that
		open(TODO, T3::base_filename(TODO => $parminfo->{user}))
				or die("can't open todo file for $parminfo->{user}");
		my $todo = {};
		my $found = false;
		while ( <TODO> )
		{
			if ( /^$todo_name\t/ )
			{
				chomp;
				(todo_fields($todo)) = split("\t");
				$found = true;
				last;
			}
		}
		close(TODO);

		die("can't find todo name $todo_name") unless $found;

		$parminfo->{timer} = $todo_name;
		$parminfo->{client} = $todo->{client};
		$parminfo->{project} = $todo->{project};
		$parminfo->{todo_link} = $todo_name;
	}

	unless ($parminfo->{force})
	{
		print_elapsed($parminfo, $timers);
		get_giventimer("start", $parminfo);
	}

	if (not exists $timers->{$parminfo->{timer}})
	{
		if (test_connection())
		{
			print STDERR "given timer doesn't exist, getting new values\n" if DEBUG >= 5;
			get_timer_parameter("client");
			get_timer_parameter("project");

			my ($phase_needed) = proj_requirements($parminfo->{client},
					$parminfo->{project}, calc_date(time));

			get_timer_parameter("phase") if $phase_needed;
		}
		else
		{
			$parminfo->{client} = 0;
			$parminfo->{project} = 0;
			$parminfo->{phase} = 0;
		}
	}
}

if ($command eq 'PAUSE')					# pause all timers
{
	if (!$timers->{T3::CURRENT_TIMER})
	{
		error(1, "no timer is actively timing");
	}

	if (!$parminfo->{force})
	{
		print_elapsed($parminfo, $timers);
		exit unless get_yn("are you sure you want to pause all timers?");
	}
}

if ($command eq 'CANCEL')					# cancel a timer
{
	if (!$parminfo->{force})
	{
		print_elapsed($parminfo, $timers);
		get_giventimer("cancel", $parminfo);

		print STDERR "warning! a cancelled timer is gone forever!\n";
		print STDERR "are you sure you want to cancel timer ", $parminfo->{timer}, "?  (y/N) ";
		exit unless <STDIN> =~ /^y/i;
	}
}

if ($command eq 'RENAME')					# new name for a timer
{
	if (!$parminfo->{force})
	{
		print_elapsed($parminfo, $timers);
		get_giventimer("new name for", $parminfo);
	}

	if (not $parminfo->{newtimer} or not $parminfo->{force})
	{
		my $defname = $parminfo->{newtimer} || $parminfo->{timer};
		$parminfo->{newtimer} = input("new name for this timer?", $defname);
	}

	if (test_connection())
	{
		get_timer_parameter("client");
		get_timer_parameter("project");

		my ($phase_needed, $tracking_needed, $comments_needed) =
				proj_requirements(
					$parminfo->{client}, $parminfo->{project},
					calc_date(time)
				);

		get_timer_parameter("phase") if $phase_needed;
	}
}

if ($command eq 'COPYINFO')
{
	if (!$parminfo->{force})
	{
		print_elapsed($parminfo, $timers);
		get_giventimer("copy info for", $parminfo);
	}

	if (not $parminfo->{newtimer} or not $parminfo->{force})
	{
		my $defname = $parminfo->{newtimer};
		$parminfo->{newtimer} = input("name for the new timer?", $defname);
	}
}

if ($command eq 'BREAKDOWN')					# break down a timer
{
	if (!$parminfo->{force})
	{
		print_elapsed($parminfo, $timers);
		get_giventimer("break down", $parminfo);
	}

	my $giventimer = $parminfo->{timer};
	if (not exists $timers->{$giventimer})
	{
		error(1, "no such timer as $giventimer");
	}

	my @parts = split(/,/, $timers->{$giventimer}->{time});
	foreach my $part (@parts)
	{
		my $mins = calc_time($part);

		if ($part =~ /^([+-]\d+)$/)
		{
			print "adjusted time by $1 minutes ($mins mins)\n";
			next;
		}

		$part =~ m{(?:(\d+)/)?(\d+)-(\d+)?};
		my $tmp = $1 ? $1 : 0;
		my ($min, $hr, $day, $mon, $year) = (localtime $2)[1..5];
		++$mon, $year += 1900;
		print "from $mon/$day/$year $hr:$min ";
		if ($3)
		{
			($min, $hr, $day, $mon, $year) = (localtime $3)[1..5];
			++$mon, $year += 1900;
			print "to $mon/$day/$year $hr:$min";
		}
		else
		{
			print "to current (still timing)";
		}
		print " at half-time" if $tmp == 2;
		#print " at half-time" if $1 == 2;
		print " ($mins mins)\n";
	}

	# no need for anything further
	exit;
}

if ($command eq 'TOTAL')					# total timers by client
{
	print STDERR "about to start TOTAL routine\n" if DEBUG >= 5;

	unless (test_connection())
	{
		print STDERR "The data store is not accessible. Action canceled.\n";
		exit;
	}

=comment
	# get totals for this weeks timers
	my ($totals, $bad_proj) = this_week_totals($parminfo->{user}, $timers);
	error(4, "can't get totals out of database") unless defined $totals;
	error(4, "can't get bad project rows") unless defined $bad_proj;

	my $grand_total = 0;
	foreach my $error (@$bad_proj)
	{
		my ($client, $hours) = @$error;

		writeln(Totals_No_Rates, $client, "ERROR! Invalid project", $hours);
		$grand_total += $hours;
	}
	foreach my $total (@$totals)
	{
		my ($client, $client_name, $rate, $hours) = @$total;

		if (not defined $rate)
		{
			writeln(Totals_No_Rates, $client, "ERROR! No rate defined", $hours);
		}
		else
		{
			writeln(Totals, $client, $client_name, $rate, $hours);
		}
		$grand_total += $hours;
	}

	# print total totals
	print "=" x length(Totals), "\n";
	writeln(Totals_No_Rates, "", "Grand Total", $grand_total);
=cut

	my %clients;
	my %projects;
	my $totals = {};
	my $min_time = rc_param(TOTAL => 'mintime') || 0;
	my %ignore_timers = map { $_ => 1 } rc_list(TOTAL => 'ignore');

	foreach (values %$timers)
	{
		next unless ref $_ eq 'HASH';
		next if exists $ignore_timers{$_->{name}};

		my $client = $_->{client} || '???';
		my $proj = $_->{project} || '???';

		unless (exists $totals->{$client})
		{
			$clients{$client} = eval { one_datum("select name from {~timer}.client where client_id = '$client'") } || '???';
			$totals->{$client} = {};
		}
		unless (exists $totals->{$client}->{$proj})
		{
			$projects{$proj} = eval { one_datum("select name from {~timer}.project where proj_id = '$proj'") } || '???';
			$totals->{$client}->{$proj} = 0;
		}

		my $mins = rounded_time($client, $_->{time});
		$mins = $min_time if calc_time($_->{time}) > 0 and $mins < $min_time;
		$totals->{$client}->{$proj} += $mins;
		$totals->{$client}->{':TOTAL'} += $mins;
	}

	foreach my $client (sort keys %$totals)
	{
		my $total_hrs = delete $totals->{$client}->{':TOTAL'};
		print "-" x length(Totals_Header), "\n";
		writeln(Totals_Header, $client, $clients{$client}, $total_hrs);

		foreach my $proj (sort keys %{$totals->{$client}})
		{
			writeln(Totals, $proj, $projects{$proj}, $totals->{$client}->{$proj});
		}
	}

	# all done
	exit;
}

if ($command eq 'AVERAGE')
{
	unless (test_connection())
	{
		print STDERR "The data store is not accessible. Action canceled.\n";
		exit;
	}

	my $emp_id = get_emp_id($parminfo->{'user'});
	print STDERR "average: emp_id is $emp_id\n" if DEBUG >= 2;
	my $logs = get_logs($emp_id);
	print STDERR "average: got ", scalar(@$logs), " total logs back\n" if DEBUG >= 3;

	my %weeks;
	foreach (@$logs)
	{
		my $period = date::period_name(date::period_num($_->{'log_date'}, 7), 7);
		$weeks{$period} += $_->{'hours'};
		print STDERR "$_->{'log_date'} ($period)     $_->{'hours'}\n" if DEBUG >= 4;
	}

	my $alltime = 0;
	foreach (sort keys %weeks)
	{
		writeln(Totals_Weekly, $_, $weeks{$_});
		$alltime += $weeks{$_};
	}

	print "=" x length(Totals_Weekly), "\n";
	writeln(Average_Weekly, range::round($alltime / scalar(keys %weeks), range::ROUND_OFF, .25));

	# all done
	exit;
}

if ($command eq 'LOG')					# log time directly to the DB
{
	unless (test_connection())
	{
		print STDERR "The data store is not accessible. Action canceled.\n";
		exit;
	}

	gather_log_info();
}

if ($command eq 'DONE')					# done with a timer
{
	unless (test_connection())
	{
		print STDERR "The data store is not accessible. Action canceled.\n";
		exit;
	}

	if (!$parminfo->{force})
	{
		print_elapsed($parminfo, $timers);
		get_giventimer("done with", $parminfo);
	}

	my $giventimer = $parminfo->{timer};
	if (!exists $timers->{$giventimer})
	{
		error(1, "no such timer as $giventimer");
	}

	print_and_gather($giventimer);
}

if ($command eq 'LOGALL')
{
	# HACK! this hardcoding, plus the idea that they have to be quarterly, should be changed
	# to allow a more configurable interface
	my %quarterly = ( log => 1, 'timer-fixes' => 1 );

	# HACK! ditto this
	my $log_timername = 'log';

	print_elapsed($parminfo, $timers);
	print <<END;

this will log out all your timers for the week, giving you the opportunity to
save them.  any timers whose names end in '-nw' are assumed to be time for the
upcoming week, and will not be logged out, although they will be renamed to
lose the '-nw' once they can be.  during this time a timer called '$log_timername'
will automatically be started for you.  note: if you want to give up logging
out a timer while you're in the middle of it, you can safely hit CTRL-C.  you
will be given an opportunity to retry the logout, cancel the timer, or just
move on.  pressing CTRL-C when _not_ in the middle of logging out a timer
exits the program as you would expect.  note2: if you have to exit before
you've logged out all timers, you can run timer -L again, and it will mostly
pick up where it left off, except that it will think that all the timers you
told it to save for next week are last week's timers, only empty; don't worry
too much about that, though, since you will still have the opportunity to
resave them if you want to.
END
	if (!$parminfo->{noconfirm})
	{
		exit unless get_yn("are you sure you want to continue?");
	}

	unless (test_connection())
	{
		print STDERR "The data store is not accessible. Action canceled.\n";
		exit;
	}

	unless ($timers->{T3::CURRENT_TIMER} eq $log_timername)
	{
		# HACK! these are hardcoded for now; should be changed to pull from a config file or something
		local $parminfo->{timer} = $log_timername;
		local $parminfo->{client} = 'TG';
		local $parminfo->{project} = 'LOG';
		local $parminfo->{phase} = 'ADM';
		do_timer_command('START', $parminfo, $timers);
	}

	TIMER: foreach my $timer (sort keys %$timers)
	{
		next if $timer =~ /^:/;					# special markers; not real timers
		next if $timer =~ /-nw/;				# timers for next week started early
		next if $timer =~ /-save/;				# timers saved from a previous timer -L
		next if exists $quarterly{$timer};		# not time to log these out yet

		# shortcut
		my $thistimer = $timers->{$timer};

		my $minutes = calc_time($thistimer->{time});
		if ($minutes == 0)
		{
			unless (get_yn("\n\ntimer $timer has no time logged this week; save it?"))
			{
				$parminfo->{timer} = $timer;
				do_timer_command('CANCEL', $parminfo, $timers);
			}
			next;
		}

		unless (exists $timers->{$timer . '-nw'} or exists $timers->{$timer . '-save'})
		{
			$parminfo->{timer} = $timer;
			$parminfo->{newtimer} = $timer . '-save';
			do_timer_command('COPYINFO', $parminfo, $timers);
		}

		# log out the timer (done)
		LOG: {
			eval
			{
				local $SIG{INT} = sub { die("user interrupt") };
				$parminfo->{timer} = $timer;
				$parminfo->{client} = undef;
				$parminfo->{project} = undef;
				$parminfo->{phase} = undef;
				print_and_gather($timer);
				do_timer_command('DONE', $parminfo, $timers);
			};

			if (exists $timers->{$timer})			# logging out failed for some reason
			{
				redo LOG if get_yn("\n\nlogging of timer $timer failed; retry?");
				if (get_yn("\ndo you want to cancel this timer?"))
				{
					$parminfo->{timer} = $timer;
					do_timer_command('CANCEL', $parminfo, $timers);
					last LOG;
				}

				if (exists $timers->{$timer . '-save'})
				{
					$parminfo->{timer} = $timer . '-save';
					do_timer_command('CANCEL', $parminfo, $timers);
				}

				next TIMER;
			}
		}

		my $saved_timer = $timer . '-nw';
		unless (exists $timers->{$saved_timer})
		{
			$saved_timer = $timer . '-save';
			$saved_timer = '' unless exists $timers->{$saved_timer};
		}
		if ($saved_timer)
		{
			if ($saved_timer =~ /-nw$/ or get_yn("\nsave this timer for next week?"))
			{
				$parminfo->{timer} = $saved_timer;
				$parminfo->{newtimer} = $timer;
				do_timer_command('RENAME', $parminfo, $timers);
			}
			else
			{
				$parminfo->{timer} = $saved_timer;
				do_timer_command('CANCEL', $parminfo, $timers);
			}
		}

		print_elapsed($parminfo, $timers);
	}

	# commands have been performed; just exit now
	exit;
}

if ($command eq 'PARSE')			# special flag for use by other processes
{
	print_parsable($parminfo, $timers);
	exit;
}

try
{
	# the main event
	do_timer_command($command, $parminfo, $timers);
}
catch
{
	error(3, $_);
};

unless ( $command eq 'LOG' )
{
	print_elapsed($parminfo, $timers);
}


#################################
# SUBROUTINES
#################################

sub usage
{
	error(0,
		"incorrect usage; usage is:\n",
		"    timer -{s|p|d|c|r|i|e|l|L|b|t|a} [-fh] [-u user] [-C clientcode] [-P projcode] [-H phasecode] " .
						"[timername [newtimername]]\n",
		"       -s:   start a timer\n",
		"       -p:   pause all timers\n",
		"       -d:   done with a timer\n",
		"       -c:   cancel a timer\n",
		"       -r:   rename/change info for a timer\n",
		"       -i:   copy info for a timer (copies all but actual time worked)\n",
		"       -e:   show elapsed time for all timers\n",
		"       -l:   log time directly to database\n",
		"       -L:   log out all current timers, optionally saving their info\n",
		"       -b:   break down a timer's portions\n",
		"       -t:   total for all timers this week (by client)\n",
		"       -a:   totals by week with weekly average\n",
		"       -f:   force (ignore all confirmations)\n",
		"       -h:   half-time timing (while watching movies, etc)\n",
		"       -u:   user name to use (default is current user)\n",
		"       -C:   client number to use (default is user-specific)\n",
		"       -P:   project code to use (no default)\n",
		"       -H:   phase code to use (no default)\n",
		"    clientcode, projcode, and phasecode must be a valid 3-character code (will be forced to uppercase)\n",
		"    timername is ignored for -p, -e, -l, -L, and -t\n",
		"    timername for other functions defaults to the running timer, if any\n",
		"    newtimername is ignored for all but -r and -i\n",
	);
}


sub error
{
	my ($exitcode, @messages) = @_;
	my $progname = $0;
	$progname =~ s@.*/@@;
	if ($cgi)
	{
		foreach (@messages)
		{
			# s/\n/<BR>\n/g;
		}
		print @messages, "\n";
		exit 0;
	}
	else
	{
		print STDERR "$progname: ", @messages, "\n";
		exit $exitcode;
	}
}


sub read_rc
{
	my %rc;
	%rc = ParseConfig(RC_FILE) if -r RC_FILE;
	return \%rc;
}

sub rc_param
{
	my ($command, $key) = @_;

	return undef unless exists $RC->{$command};
	return undef unless exists $RC->{$command}->{$key};
	return $RC->{$command}->{$key};
}

sub rc_list
{
	my ($command, $key) = @_;

	return () unless exists $RC->{$command};
	return () unless exists $RC->{$command}->{$key};
	if (ref $RC->{$command}->{$key} eq 'ARRAY')
	{
		return @{$RC->{$command}->{$key}};
	}
	else
	{
		return ($RC->{$command}->{$key});
	}
}


sub get_giventimer
{
	my ($function, $parminfo) = @_;

	TIMER: {
		my $new = input("$function what timer? ", $parminfo->{timer});
		if ($new =~ /\s/)
		{
			print STDERR "timer name can't have a space; sorry\n";
			redo TIMER;
		}
		elsif ($new =~ /^:/)
		{
			print STDERR "timer name can't start with a colon; sorry\n";
			redo TIMER;
		}

		$parminfo->{timer} = $new if $new;
	}
}


sub get_timer_parameter
{
	my ($parmname) = @_;
	print "wantarray is ", defined wantarray ? wantarray : "undef", "\n"
			if DEBUG >= 4;

	# objinfo would be the specified timer, which we get here
	my $objinfo = $timers->{$parminfo->{timer}};

	# this is somewhat complicated.  we need to figure out what the proper thing (client, project, or phase)
	# should be, and then use it as the default.  now, we have three possible places to get this info from:
	# the default for this user (from the database; get_parameter knows how to retrieve that), the thing
	# already set (for a pre-existing timer; this comes from objinfo), or the thing specified on the command
	# line (if specified at all; this comes from parminfo).  for most cases, the priority is: command line,
	# pre-existing, default.  for the start command, however, a pre-existing parameter can't be changed if it
	# exists, so we use it and exit.	also, if -f (force) was specified (that flag is in parminfo), we can
	# quit right there.

	# got it? here we go ...

	my $opts = {};
	# this will keep people from being able to change parameters if the command is "start"
	$opts->{RESTRICT_CHANGES} = true if $command eq 'START';

	return get_parameter($parmname, $parminfo, $objinfo, $opts);
}


sub print_elapsed
{
	my ($parminfo, $timers) = @_;
	print_parsable($parminfo, $timers) and return if $cgi;

	#print Dumper($timers);
	print "\nTIMERS FOR $parminfo->{user}:\n";
	foreach my $tname (sort keys %$timers)
	{
		# ignore tags
		next if substr($tname, 0, 1) eq ':';

		my $timer = $timers->{$tname};

		my $minutes = calc_time($timer->{time});
		my $hours = range::round($minutes / 60, range::ROUND_DOWN);
		$minutes = $minutes - $hours * 60;
		my $date = calc_date($timer->{time});
		my $curtimer_marker = $timers->{T3::CURRENT_TIMER} &&
				$timers->{T3::CURRENT_TIMER} eq $tname ? "==>" : "";

		writeln(Elapsed, $curtimer_marker, $tname, $timer->{client},
				$timer->{project}, $timer->{phase} ? ",$timer->{phase}" : "",
				$hours, $minutes, $date,
				$timer->{time} =~ m{/\d+-$} ? "HALF-TIMING" : "");
	}

	print $timers->{T3::CURRENT_TIMER}
			? "active timer is $timers->{T3::CURRENT_TIMER}"
			: "no timer is active";
	print "\n\n";
}

sub print_parsable
{
	my ($parminfo, $timers) = @_;

	my $user = $parminfo->{user};
	while (my ($tname, $timer) = each %$timers)
	{
		print "$tname\n" and next if $parminfo->{parse_fmt} eq 't';

		my $client = $timer->{client};
		foreach my $part (reverse split(/,/, $timer->{time}))
		{
			print "<TIMER>" if $parminfo->{parse_fmt} eq 'x';
			print "$user:$tname:$client:";

			my $mins = calc_time($part);
			print "$mins:";

			if ($part =~ /^([+-]\d+)$/)
			{
				# raw adjustment; date and time not known
				print ":";
				next;
			}

			my ($start, $end) = ($part =~ m{(?:(\d+)/)?(\d+)-(\d+)?});
			print "$start:$end";		# if current, $end will be blank field

			# not sure if half-time is needed, so we'll leave it out for now
			# print " at half-time" if $1 == 2;

			print "</TIMER>" if $parminfo->{parse_fmt} eq 'x';
			print "\n";
		}
	}
	return 1;
}


sub rounded_time
{
	my ($client, $time) = @_;
	print STDERR "rounded_time: $client, $time\n" if DEBUG >= 4;

	my $hours = calc_time($time) / 60;

	my ($rounding, $to_nearest);
	if (eval { ($rounding, $to_nearest) = client_rounding($client) })
	{
		$hours = range::round($hours, $rounding, $to_nearest);
		print STDERR "rounding time for client $client: $rounding to $to_nearest, result $hours\n" if DEBUG >= 4;
	}
	return $hours;
}


sub print_and_gather
{
	my ($giventimer) = @_;

	my $thistimer = $timers->{$giventimer};
	my $minutes = calc_time($thistimer->{time});
	my $hours = range::round($minutes / 60, range::ROUND_DOWN),
	my $date = calc_date($thistimer->{time});
	my $client = $thistimer->{client};
	print "\ntimer: $giventimer\n";
	print "total time is $minutes mins ($hours hrs ", $minutes - $hours * 60, " mins) on $date for $client\n";
	print "please remember this in case there is a problem!\n\n";
	if (!$parminfo->{noconfirm})
	{
		print "press return to continue ...\n";
		<STDIN>;
	}

	gather_log_info($giventimer);
}


sub gather_log_info
{
	my ($log_timer) = @_;

	# For logging timers, we MUST ask for codes; no 'force' allowed.  But
	# the noconfirm option can still turn off the annoying confirmations.
	$parminfo->{force} = false;

	# a shortcut
	my $timer = defined $log_timer ? $timers->{$log_timer} : undef;
	print STDERR "$log_timer timer: ", Dumper($timer) if DEBUG >= 2;

	my ($emp_id, $emp_fullname, $client, $client_name, $rounding, $to_nearest, $date, $hours, $project, $project_name,
			$phase, $phase_name, $tracking, $tracking_name, $comments);

	# please note that the order you ask for the data elements in is
	# *very* important ... the following things are true:
	#	you have to do employee before you do client
	#	you have to do employee before you do project
	#	you have to do date before you do client
	#	you have to do date before you do project
	# 	you have to do client before you do hours
	#	you have to do client before you do project
	#	you have to do client before you do tracking
	#	you have to do project before you do phase
	#	you have to do project before you do tracking
	#	you have to do project before you do comments
	# based on this, there is not a whole lot you can do differently in
	# the order chosen below, so DON'T MUCK WITH IT!

	($emp_id, $emp_fullname) = get_timer_parameter("employee");

	# $parminfo->{user} may not match emp_id at this point; that's ok.
	# It lets us track the actual person who submitted the command.

	$parminfo->{date} = $date = input(
			"Date:",
			$timer ? calc_date($timer->{time}) : date::today(),
			{
				VALID		=>	\&date::isValid,
				VALID_ERR	=>	"  {Invalid date!}\n",
			}
	);


	# Get client info
	($client, $client_name) = get_timer_parameter("client");

	HOURS: {
		($rounding, $to_nearest) = client_rounding($client);

		$hours = input("Hours:", $timer ? range::round(calc_time($timer->{time}) / 60, $rounding, $to_nearest) : 0);
		print "  {Hours must divisible by $to_nearest}\n" and redo HOURS
				unless $hours == range::round($hours, range::ROUND_OFF, $to_nearest);
		print "  {Hours must be greater than zero}\n" and redo HOURS unless $hours > 0;
	}
	$parminfo->{hours} = $hours;

	# Get project info
	($project, $project_name) = get_timer_parameter("project");

	my ($phase_needed, $tracking_needed, $comments_needed) = proj_requirements($client, $project, $date);

	# Get phase information
	($phase, $phase_name) = $phase_needed ? get_timer_parameter("phase") : (undef, "");
	$parminfo->{phase} = $phase;

	($tracking, $tracking_name) = $tracking_needed ?  get_timer_parameter("client tracking code") : (undef, "");
	$parminfo->{tracking} = $tracking;

	COMMENTS: {
		$comments = undef;
		last unless $comments_needed;
		print "\nEnter comments below (maximum 255 chars):\n";
		print "  (255 chars is a little over 3 lines if your screen is 80\n";
		print "   columns wide--or almost exactly two lines if your screen is\n";
		print "   125 columns wide--and you don't hit RETURN at all (which you shouldn't))\n";
		print "Enter ^D (control-D) on a line by itself to finish the comments.\n";
		local ($/) = undef;
		$comments = input();
		while ($comments =~ s/^\s+$//) {};				# no completely blank lines
		while ($comments =~ s/^\n//) {};				# no extra newlines in front
		$comments =~ s/\s*\n+\s*$//;					# none at the end either
		print "  {You must have comments}\n\n" and redo COMMENTS if not $comments;
		print "  {Comments too long!}\n\n" and redo COMMENTS if length($comments) > 255;
	}
	$parminfo->{comments} = $comments;

	print "working.....\n";

	# show everything and double check:
	writeln(Log,
			$emp_id,	$emp_fullname,
			$client,	$client_name,				$date,
			$project,	$project_name,
			$phase,		$phase_name,				$hours,
							$tracking, $tracking_name
	);
	writeln(Log_Comments, $comments);

	<STDIN>;					# HACK! don't know why this is necessary
	unless (get_yn("\n\nis everything okay?"))
	{
		die("\n  {Try to log this timer out again later.}\n");
	}

	print STDERR "parms after gather_log_info: ", Dumper($parminfo) if DEBUG >= 4;
}
