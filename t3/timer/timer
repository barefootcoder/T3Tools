#! /usr/bin/perl -w

# For RCS:
# $Date$
#
# $Id$
# $Revision$

use strict;

#use Barefoot::debug;

use CGI;
use Getopt::Std;

use Barefoot::base;
use Barefoot::date;
use Barefoot::range;
use Barefoot::format;
use Barefoot::exception;
use Barefoot::input qw<get_yn input>;
use Barefoot::T3Timer qw<get_timer_info do_timer_command calc_date calc_time
		this_week_totals insert_time_log>;
use Barefoot::T3::valid qw<get_parameter>;
use Barefoot::T3::db_get qw<client_rounding proj_requirements>;


#################################
# CONSTANTS
#################################

use constant DBSERVER_DIRECTIVE => 'DBServer';
use constant DATABASE_DIRECTIVE => 'Database';
use constant TIMERDIR_DIRECTIVE => 'TimerDir';


#################################
# FORMATS
#################################

use constant Elapsed =>
	'@<< @<<<<<<<<<<<<<<<<<  for @<<,@<<@<<<<< at @> hrs @> mins (@>>>>>>>>>) @<<<';

use constant Totals =>
	'@<< @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  $@##.##  total: @##.## hours';
use constant Totals_No_Rates =>
	'@<< @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<           total: @##.## hours';

use constant Log =>
	'
	Employee:  @<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<         Date:
	Client:    @<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<         @<<<<<<<<<
	Project:   @<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<         Hours:
	Phase:     @<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<         @##.##

	  Client Tracking Code: @<<<<<<<<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

	Comments:';
use constant Log_Comments =>
	'      ~~^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<';


#################################';
# OPTIONS AND ENVIRONMENT VARS
#################################

our $timerinfo = {};
my $command_strings = {
	s	=>	"START",
	e	=>	"LIST",
	d	=>	"DONE",
	l	=>	"LOG",
	c	=>	"CANCEL",
	p	=>	"PAUSE",
	r	=>	"RENAME",
	b	=>	"BREAKDOWN",
	t	=>	"TOTAL",
	'@'	=>	"PARSE",
};
our ($cgi, $command, $workgroup);

if (-t STDOUT or @ARGV)
{
	usage() if @ARGV == 0;

	my $opt = {};
	getopts('sedlcprbtfhu:C:P:H:@:', $opt);
	$timerinfo->{force} = defined $opt->{f};
	$timerinfo->{noconfirm} = defined $opt->{f};
	$timerinfo->{halftime} = defined $opt->{h};
	$timerinfo->{user} = $opt->{u};
	$timerinfo->{client} = $opt->{C};
	$timerinfo->{project} = string::upper($opt->{P});
	$timerinfo->{phase} = string::upper($opt->{H});
	$timerinfo->{parse_fmt} = $opt->{'@'};

	$timerinfo->{newname} = $ARGV[1];

	foreach my $copt ( qw<s e d l c p r b t @> )
	{
		if (exists $opt->{$copt})
		{
			error(2, "you must specify exactly one command (s,e,d,l,c,p,r,b)")
					if defined $command;
			$command = $command_strings->{$copt};
			# print STDERR "defined command as $command\n";
		}
	}
}
else
{
	$cgi = new CGI;
	$workgroup = $cgi->param('workgroup');
	$timerinfo->{user} = $cgi->param('user');
	$timerinfo->{client} = $cgi->param('client');
	$timerinfo->{giventimer} = $cgi->param('timername');
	$timerinfo->{newname} = $cgi->param('newname');

	$timerinfo->{force} = 1;					# no input when run as a CGI
	$timerinfo->{parse_fmt} = 'x';				# always output XML-style

	$command = $command_strings->{string::left($cgi->param('mode'), 1)};

	# get a header out there so the server won't choke
	print $cgi->header('text/plain');
}


#################################
# CHECK FOR ERRORS
#################################



#################################
# main()
#################################

# fill up some basic info in our timerinfo object
try
{
	get_timer_info($ARGV[0], $timerinfo);
}
catch
{
	error(3, $_);
};

if ($command eq 'START')					# start a timer
{
	unless ($timerinfo->{force})
	{
		print_elapsed($timerinfo);
		get_giventimer("start", $timerinfo);
	}

	if (not exists $timerinfo->{timers}->{$timerinfo->{giventimer}})
	{
		if ($timerinfo->{connected})
		{
			print STDERR "given timer doesn't exist, getting new values\n"
					if DEBUG >= 5;
			get_timer_parameter("client");
			get_timer_parameter("project");

			my ($phase_needed) = proj_requirements($timerinfo->{client},
					$timerinfo->{project}, calc_date(time));

			get_timer_parameter("phase") if $phase_needed;
		}
		else
		{
			$timerinfo->{client} = 0;
			$timerinfo->{project} = 0;
			$timerinfo->{phase} = 0;
		}
	}
}

if ($command eq 'PAUSE')					# pause all timers
{
	if (!$timerinfo->{curtimer})
	{
		error(1, "no timer is actively timing");
	}

	if (!$timerinfo->{force})
	{
		print_elapsed($timerinfo);
		exit unless get_yn("are you sure you want to pause all timers?");
	}
}

if ($command eq 'CANCEL')					# cancel a timer
{
	if (!$timerinfo->{force})
	{
		print_elapsed($timerinfo);
		get_giventimer("cancel", $timerinfo);

		print STDERR "warning! a cancelled timer is gone forever!\n";
		print STDERR "are you sure you want to cancel timer ",
				$timerinfo->{giventimer}, "?  (y/N) ";
		exit unless <STDIN> =~ /^y/i;
	}
}

if ($command eq 'RENAME')					# new name for a timer
{
	if (!$timerinfo->{force})
	{
		print_elapsed($timerinfo);
		get_giventimer("new name for", $timerinfo);
	}

	if (not $timerinfo->{newname} or not $timerinfo->{force})
	{
		my $defname = $timerinfo->{newname} || $timerinfo->{giventimer};
		$timerinfo->{newname} = input("new name for this timer?", $defname);
	}

	if ($timerinfo->{connected})
	{
		get_timer_parameter("client");
		get_timer_parameter("project");

		my ($phase_needed, $tracking_needed, $comments_needed) = 
				proj_requirements(
					$timerinfo->{client}, $timerinfo->{project},
					calc_date(time)
				);

		get_timer_parameter("phase") if $phase_needed;
	}
}

if ($command eq 'BREAKDOWN')					# break down a timer
{
	if (!$timerinfo->{force})
	{
		print_elapsed($timerinfo);
		get_giventimer("break down", $timerinfo);
	}

	my @parts = split(/,/,
			$timerinfo->{timers}->{$timerinfo->{giventimer}}->{time});
	foreach my $part (@parts)
	{
		my $mins = calc_time($part);

		if ($part =~ /^([+-]\d+)$/)
		{
			print "adjusted time by $1 minutes ($mins mins)\n";
			next;
		}

		$part =~ m{(?:(\d+)/)?(\d+)-(\d+)?};
		my $tmp = $1 ? $1 : 0;
		my ($min, $hr, $day, $mon, $year) = (localtime $2)[1..5];
		++$mon, $year += 1900;
		print "from $mon/$day/$year $hr:$min ";
		if ($3)
		{
			($min, $hr, $day, $mon, $year) = (localtime $3)[1..5];
			++$mon, $year += 1900;
			print "to $mon/$day/$year $hr:$min";
		}
		else
		{
			print "to current (still timing)";
		}
		print " at half-time" if $tmp == 2;
		#print " at half-time" if $1 == 2;
		print " ($mins mins)\n";
	}

	# no need for anything further
	exit;
}

if ($command eq 'TOTAL')					# total timers by client
{
	unless ($timerinfo->{connected})
	{
		print STDERR "The data store is not accessible. Action canceled.\n";
		exit;
	}

	# get totals for this weeks timers
	my ($totals, $bad_proj) = this_week_totals($timerinfo->{user});
	error(4, "can't get totals out of database") unless defined $totals;
	error(4, "can't get bad project rows") unless defined $bad_proj;

	my $grand_total = 0;
	foreach my $error (@$bad_proj)
	{
		my ($client, $hours) = @$error;

		writeln(Totals_No_Rates, $client, "ERROR! Invalid project", $hours);
		$grand_total += $hours;
	}
	foreach my $total (@$totals)
	{
		my ($client, $client_name, $rate, $hours) = @$total;

		if (not defined $rate)
		{
			writeln(Totals_No_Rates, $client,
					"ERROR! No rate defined", $hours);
		}
		else
		{
			writeln(Totals, $client, $client_name, $rate, $hours);
		}
		$grand_total += $hours;
	}

	# print total totals
	print "=" x length(Totals), "\n";
	writeln(Totals_No_Rates, "", "Grand Total", $grand_total);

	# all done
	exit;
}

if ($command eq 'LOG')					# log time directly to the DB
{
	unless ($timerinfo->{connected})
	{
		print STDERR "The data store is not accessible. Action canceled.\n";
		exit;
	}
	
	gather_log_info($timerinfo);
}

if ($command eq 'DONE')					# done with a timer
{
	unless ($timerinfo->{connected})
	{
		print STDERR "The data store is not accessible. Action canceled.\n";
		exit;
	}
	
	if (!$timerinfo->{force})
	{
		print_elapsed($timerinfo);
		get_giventimer("done with", $timerinfo);
	}

	if (!exists $timerinfo->{timers}->{$timerinfo->{giventimer}})
	{
		error(1, "no such timer as $timerinfo->{giventimer}");
	}

	my $thistimer = $timerinfo->{timers}->{$timerinfo->{giventimer}};
	my $minutes = calc_time($thistimer->{time});
	my $hours = range::round($minutes / 60, range::ROUND_DOWN),
	my $date = calc_date($thistimer->{time});
	my $client = $thistimer->{client};
	print "\ntotal time is $minutes mins ($hours hrs ", $minutes - $hours * 60,
		" mins) on $date for $client\n";
	print "please remember this in case there is a problem!\n\n";
	if (!$timerinfo->{force})
	{
		print "press return to continue ...\n";
		<STDIN>;
	}

	gather_log_info($timerinfo, $timerinfo->{giventimer});
}

if ($command eq 'PARSE')			# special flag for use by other processes
{
	print_parsable($timerinfo);
	exit;
}

try
{
	# the main event
	do_timer_command($command, $timerinfo);
}
catch
{
	error(3, $_);
};

unless ( $command eq 'LOG' )
{
	print_elapsed($timerinfo);
}


#################################
# SUBROUTINES
#################################

sub usage
{
	error(0,
		"incorrect usage; usage is:\n",
		"    timer -{s|p|d|c|r|e|l|b|t} [-fh] [-u user] [-C clientnum] ",
						"[-P projcode] [timername [newtimername]] ",
						"[-H phasecode]\n",
		"       -s:   start a timer\n",
		"       -p:   pause all timers\n",
		"       -d:   done with a timer\n",
		"       -c:   cancel a timer\n",
		"       -r:   rename/change info for a timer\n",
		"       -e:   show elapsed time for all timers\n",
		"       -l:   log time directly to database\n",
		"       -b:   break down a timer's portions\n",
		"       -t:   total for all timers this week (by client)\n",
		"       -f:   force (ignore all confirmations)\n",
		"       -h:   half-time timing (while watching movies, etc)\n",
		"       -u:   user name to use (default is current user)\n",
		"       -C:   client number to use (default is user-specific)\n",
		"       -P:   project code to use (no default)\n",
		"       -H:   phase code to use (no default)\n",
		"    clientnum must be a valid 3-digit code\n",
		"    projcode and phasecode must be a valid 3-character code ",
				"\n	(will be forced to uppercase)\n",
		"    timername is ignored for -p, -e, -l, and -t\n",
		"    newtimername is ignored for all but -r\n",
	);
}


sub error
{
	my ($exitcode, @messages) = @_;
	my $progname = $0;
	$progname =~ s@.*/@@;
	if ($cgi)
	{
		foreach (@messages)
		{
			# s/\n/<BR>\n/g;
		}
		print @messages, "\n";
		exit 0;
	}
	else
	{
		print STDERR "$progname: ", @messages, "\n";
		exit $exitcode;
	}
}


sub get_giventimer
{
	my ($function, $timerinfo) = @_;

	TIMER: {
		my $new = input("$function what timer? ",$timerinfo->{giventimer});
		if ($new =~ /\s/)
		{
			print STDERR "timer name can't have a space; sorry\n";
			redo TIMER;
		}
		$timerinfo->{giventimer} = $new if $new;
	}
}


sub get_timer_parameter
{
	my ($parmname) = @_;

	# timerinfo can double as parminfo inside get_parameter
	# objinfo would be the current timer, which we get here
	my $objinfo = $timerinfo->{timers}->{$timerinfo->{giventimer}};

	# this is somewhat complicated.  we need to figure out what the
	# proper thing (client, project, or phase) should be, and then use
	# it as the default.  now, we have three possible places to get this
	# info from: the default for this user (from the database; get_parameter
	# knows how to retrieve that), the thing already set (for a pre-existing
	# timer; this comes from objinfo), or the thing specified on the command
	# line (if specified at all; this comes from parminfo, a.k.a. timerinfo).
	# for most cases, the priority is: command line, pre-existing, default.
	# for the start command, however, a pre-existing parameter can't be
	# changed if it exists, so we use it and exit.	also, if -f (force) was
	# specified (that flag is in parminfo), we can quit right there.

	# got it? here we go ...

	my $opts = {};
	# this will keep people from being able to change parameters if the
	# command is "start"
	$opts->{RESTRICT_CHANGES} = true if $command eq 'START';

	return get_parameter($parmname, $timerinfo, $objinfo, $opts);
}


sub print_elapsed
{
	my ($timerinfo) = @_;
	print_parsable($timerinfo) and return if $cgi;

	print "\nTIMERS FOR $timerinfo->{user}:\n";
	my $timer;
	foreach $timer (keys %{$timerinfo->{timers}})
	{
		my $minutes = calc_time($timerinfo->{timers}->{$timer}->{time});
		my $hours = range::round($minutes / 60, range::ROUND_DOWN);
		$minutes = $minutes - $hours * 60;
		my $date = calc_date($timerinfo->{timers}->{$timer}->{time});
		my $curtimer_marker = $timerinfo->{curtimer} &&
				$timerinfo->{curtimer} eq $timer ? "==>" : "";

		writeln(Elapsed, $curtimer_marker, $timer,
				$timerinfo->{timers}->{$timer}->{client},
				$timerinfo->{timers}->{$timer}->{project},
				$timerinfo->{timers}->{$timer}->{phase} ?
					",$timerinfo->{timers}->{$timer}->{phase}":"",
				$hours, $minutes, $date,
				$timerinfo->{timers}->{$timer}->{time} =~ m{/\d+-$}
					? "HALF-TIMING" : "");
	}

	print $timerinfo->{curtimer} ? "active timer is $timerinfo->{curtimer}"
		: "no timer is active";
	print "\n\n";
}

sub print_parsable
{
	my ($timerinfo) = @_;

	my $user = $timerinfo->{user};
	foreach my $timer (keys %{$timerinfo->{timers}})
	{
		print "$timer\n" and next if $timerinfo->{parse_fmt} eq 't';

		my $client = $timerinfo->{timers}->{$timer}->{client};
		foreach my $part (reverse split(/,/,
				$timerinfo->{timers}->{$timer}->{time}))
		{
			print "<TIMER>" if $timerinfo->{parse_fmt} eq 'x';
			print "$user:$timer:$client:";

			my $mins = calc_time($part);
			print "$mins:";

			if ($part =~ /^([+-]\d+)$/)
			{
				# raw adjustment; date and time not known
				print ":";
				next;
			}

			my ($start, $end) = ($part =~ m{(?:(\d+)/)?(\d+)-(\d+)?});
			print "$start:$end";		# if current, $end will be blank field

			# not sure if half-time is needed, so we'll leave it out for now
			# print " at half-time" if $1 == 2;

			print "</TIMER>" if $timerinfo->{parse_fmt} eq 'x';
			print "\n";
		}
	}
	return 1;
}

sub gather_log_info
{
	my ($timerinfo, $log_timer) = @_;

	# For logging timers, we MUST ask for codes; no 'force' allowed.  But
	# the noconfirm option can still turn off the annoying confirmations.
	$timerinfo->{force} = false;

	# a shortcut
	my $timer = defined $log_timer
			? $timerinfo->{timers}->{$log_timer} : undef;

	my ($emp_id, $emp_fullname, $client, $client_name, $rounding, $to_nearest,
			$date, $hours, $project, $project_name, $phase, $phase_name,
			$tracking, $tracking_name, $comments);

	# please note that the order you ask for the data elements in is
	# *very* important ... the following things are true:
	#	you have to do employee before you do client
	#	you have to do employee before you do project
	#	you have to do date before you do client
	#	you have to do date before you do project
	# 	you have to do client before you do hours
	#	you have to do client before you do project
	#	you have to do client before you do tracking
	#	you have to do project before you do phase
	#	you have to do project before you do tracking
	#	you have to do project before you do comments
	# based on this, there is not a whole lot you can do differently in
	# the order chosen below, so DON'T MUCK WITH IT!

	($emp_id, $emp_fullname) = get_timer_parameter("employee");
	
	# $timerinfo->{user} may not match emp_id at this point; that's ok.
	# It lets us track the actual person who submitted the command.

	DATE: {
		$date = input("Date:", $timer ? calc_date($timer->{time}) : date::today());
		print "  {Invalid date!}\n" and redo DATE unless date::isValid($date);
	}
	$timerinfo->{date} = $date;


	# Get client info
	($client, $client_name) = get_timer_parameter("client");

	HOURS: {
		($rounding, $to_nearest) = client_rounding($client);

#print "$_ => $timer->{$_}\n" foreach keys %$timer;

		$hours = input("Hours:",
				$timer ? range::round(calc_time($timer->{time}) / 60,
						$rounding, $to_nearest) : 0);
		print "  {Hours must divisible by $to_nearest}\n" and redo HOURS
				unless $hours == range::round($hours,
					range::ROUND_OFF, $to_nearest);
		print "  {Hours must be greater than zero}\n" and redo HOURS
				unless $hours > 0;
	}
	$timerinfo->{hours} = $hours;

	# Get project info
	($project, $project_name) = get_timer_parameter("project");

	my ($phase_needed, $tracking_needed, $comments_needed)
			= proj_requirements($client, $project, $date);

	# Get phase information
	($phase, $phase_name) = $phase_needed
			? get_timer_parameter("phase") : ("","");

	($tracking, $tracking_name) = $tracking_needed ?
			get_timer_parameter("client tracking code") : ("","");
	$timerinfo->{tracking} = $tracking;

	COMMENTS: {
		$comments = "";
		last unless $comments_needed;
		print "\nEnter comments below (maximum 255 chars):\n";
		print "  (255 chars is a little over 3 lines if your screen is 80\n";
		print "   columns wide and you don't hit RETURN at all (which you ",
				"shouldn't))\n";
		print "Enter ^D (control-D) on a line by itself to finish the ",
				"comments.\n";
		local ($/) = undef;
		$comments = input();
		while ($comments =~ s/^\s+$//) {};	# no completely blank lines
		while ($comments =~ s/^\n//) {};	# no extra newlines in front
		$comments =~ s/\s*\n+\s*$//;		# none at the end either
		print "  {You must have comments}\n\n" and redo COMMENTS
				if not $comments;
		print "  {Comments too long!}\n\n" and redo COMMENTS
				if length($comments) > 255;
	}
	$timerinfo->{comments} = $comments;

	print "working.....\n";

	# show everything and double check:
	writeln(Log, $emp_id, $emp_fullname,
			$client, $client_name, $date,
			$project, $project_name,
			$phase, $phase_name, $hours,
			$tracking, $tracking_name);
	writeln(Log_Comments, $comments);

	unless (get_yn("\n\nis everything okay?"))
	{
		print "\n  {Try to log this timer out again later.}\n";
		exit 1;
	}

=comment
	my $error = insert_time_log($emp_id, $client, $project, $phase,
			$tracking, $date, $hours, $comments);
	if ($error)
	{
		print "\nthere was some error!\n";
		print "{$error}\n";
		print "please report this to a system administrator for resolution\n";
		exit();
	}
	else
	{
		print "\ntime has been logged to Sybase\n\n";
	}
=cut
}
