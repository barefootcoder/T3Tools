#! /bin/ksh

# For RCS:
# $Date$
# $Log$
# Revision 1.3  1999/12/10 04:23:23  buddy
# major changes to the way training rates are calculated:
#     no calculation until project completed
#     zeroing out of log (payroll) rows for training classes (this keeps
#          these rows from affecting profit calculations)
#     have to insert bill_rate along with 'training work' rows (otherwise
#          referall commission doesn't get calc'ed for some strange reason)
#
# Revision 1.2  1999/10/28 14:18:20  buddy
# removed stuff relegated to make_rates
# added handling for training rates
# various bug fixes
#
# Revision 1.1  1999/09/01 17:52:13  buddy
# Initial revision
#
# Revision 1.1  1999/01/04 19:46:09  buddy
# Initial revision (of make_rates, where this was originally)
#
# $Id$
# $Revision$

. /usr/local/bin/kshlib

server=SYBASE_1
user=$USER
destdb=TIMER

run_query -S$server -U$user -D$destdb <<-END

	-- stored procedures for figuring billing / commission information


	-- we have to create the temp table so that the stored procedures
	-- will compile ... since we don't need any records, we'll use
	-- a where clause that will always be false
	$(build_emp_comm "1 = 0")


	-- stored procedure to calculate how much to bill
	drop procedure billing_amounts
	go

	create procedure billing_amounts
	as
		-- things that don't get billed have no billing amounts
		update #emp_comm
		set amt_billed = 0, empcomm = 0
		from #emp_comm ec, project p, project_type pt
		where ec.client = p.client
		and ec.proj = p.proj
		and p.proj_type = pt.proj_type
		and pt.requires_billing = 0

		-- now figure out standard billing rates
		update #emp_comm
		set billrate = br.rate, salescomm = 0
		from #emp_comm ec, bill_rate br, project p, project_type pt
		where ec.amt_billed is NULL
		and ec.proj = p.proj
		and p.proj_type = pt.proj_type
		and pt.requires_billing = 1
		and pt.bill_by_employee = 0
		and pt.use_training_rates = 0
		and ec.client = br.client
		and ec.proj = br.proj
		and br.fixed_price_days is NULL
		and ec.date between br.start_date and br.end_date

		-- and likewise for resource billing rates
		update #emp_comm
		set billrate = rr.rate, salescomm = 0
		from #emp_comm ec, resource_rate rr, resource_employee re,
				project p, project_type pt
		where ec.amt_billed is NULL
		and ec.proj = p.proj
		and p.proj_type = pt.proj_type
		and pt.requires_billing = 1
		and pt.bill_by_employee = 1
		and pt.use_training_rates = 0
		and ec.emp = re.emp
		and re.resrc = rr.resrc
		and ec.client = rr.client
		and ec.date between rr.start_date and rr.end_date
		and ec.date between re.start_date and re.end_date

		-- and likewise for training rates
		update #emp_comm
		set billrate = tr.rate * tc.num_students
		from #emp_comm ec, training_class tc, training_rate tr
		where ec.source_tbl = 'training_class'
		and ec.client = tc.client
		and ec.proj = tc.proj
		and ec.date = tc.start_time
		and tc.client = tr.client
		and tc.proj = tr.proj
		and tc.start_time between tr.start_date and tr.end_date
		-- while we're here, may as well zero out the log entries
		-- attached to training projects
		update #emp_comm
		set billrate = 0, amt_paid = 0, salescomm = 0 --, payrate = 0
		from #emp_comm ec, project p, project_type pt
		where ec.source_tbl not in ('training_class', 'training work')
		and ec.client = p.client
		and ec.proj = p.proj
		and p.proj_type = pt.proj_type
		and pt.use_training_rates = 1

		-- now figure bill hours (including billing ratios)
		-- first general client billing ratios
		update #emp_comm
		set bill_hours = $(round 'ec.hours / br.ratio' .25 U)
		from #emp_comm ec, billing_ratio br
		where ec.billrate > 0
		and ec.emp = br.emp
		and ec.client = br.client
		and br.proj is NULL
		and ec.date between br.start_date and br.end_date
		-- now project specific billing ratios
		update #emp_comm
		set bill_hours = $(round 'ec.hours / br.ratio' .25 U)
		from #emp_comm ec, billing_ratio br
		where ec.billrate > 0
		and ec.emp = br.emp
		and ec.client = br.client
		and ec.proj = br.proj
		and ec.date between br.start_date and br.end_date
		-- finally, entries with no billing ratios
		update #emp_comm
		set bill_hours = ec.hours
		from #emp_comm ec
		where ec.billrate is not NULL
		and ec.bill_hours is NULL

		-- now billing amount is real easy
		update #emp_comm
		set amt_billed = bill_hours * billrate
		where bill_hours > 0

		-- now get fixed price billing rates, which are (predictably)
		-- more difficult to figure
		-- first figure out which fixed price rates we have to worry about
		select distinct ec.client, ec.proj, br.rate, br.fixed_price_days,
				$(period_num ec.date br.fixed_price_days) 'period_num',
				$(period_day br.start_date br.fixed_price_days) 'start_day',
				convert(datetime, NULL) 'period_start',
				convert(datetime, NULL) 'period_end',
				convert(numeric(5,2), NULL) 'number_hours'
		into #fixed_price_periods
		from #emp_comm ec, bill_rate br
		where ec.amt_billed is NULL
		and ec.client = br.client
		and ec.proj = br.proj
		and br.fixed_price_days is not NULL
		and ec.date between br.start_date and br.end_date
		-- do we have any winners?
		if exists (select 1 from #fixed_price_periods)
		begin
			-- we'll need to know the date range we care about
			declare @min_date datetime, @max_date datetime
			select @min_date = min(ec.date)
			from #emp_comm ec
			select @max_date = max(ec.date)
			from #emp_comm ec
			-- get start dates for each period
			update #fixed_price_periods
			set period_start = $(period_start period_num fixed_price_days)
			-- and end dates
			update #fixed_price_periods
			set period_end = dateadd(day, fixed_price_days - 1, period_start)
			-- handle partial first period
			update #fixed_price_periods
			set period_start = @min_date,
				rate = rate / fixed_price_days * 
						(datediff(day, @min_date, period_end) + 1)
			where period_start < @min_date
			-- likewise for partial last period
			update #fixed_price_periods
			set period_end = @max_date,
				rate = rate / fixed_price_days * 
						(datediff(day, period_start, @max_date) + 1)
			where period_end > @max_date
			-- have to index it for the cursor
			create unique index fixed_price
			on #fixed_price_periods (client, proj, period_start)
			-- make a cursor to go through the table
			declare fixed_price cursor
			for
				select client, proj, rate, fixed_price_days,
				period_start, period_end
				from #fixed_price_periods
			for update of number_hours
			-- vars to hold the cursor columns
			declare @client char(3), @proj char(3), @rate money, @days int,
					@period_start datetime, @period_end datetime
			-- open the cursor
			open fixed_price
			-- get the first row
			fetch fixed_price
			into @client, @proj, @rate, @days, @period_start, @period_end
			-- loop through
			while (@@sqlstatus = 0)
			begin
				-- figure out how many hours for this row
				declare @hours numeric(5,2)
				select @hours = (
					select sum(hours) 
					from #emp_comm
					where client = @client
					and proj = @proj
					and date between @period_start and @period_end
				)
				-- and put it in
				update #fixed_price_periods
				set number_hours = @hours
				where current of fixed_price
				-- get the next row
				fetch fixed_price
				into @client, @proj, @rate, @days, @period_start, @period_end
			end
			-- close the cursor
			close fixed_price
			-- debugging
			-- select * from #fixed_price_periods
			-- now update the original table
			update #emp_comm
			set amt_billed =
					convert(money, fpp.rate / fpp.number_hours * ec.hours)
			from #emp_comm ec, #fixed_price_periods fpp
			where ec.client = fpp.client
			and ec.proj = fpp.proj
			and ec.date between fpp.period_start and fpp.period_end
		end

		-- set salescomms and refcomms to 0 initially
		update #emp_comm
		set salescomm = 0, refcomm = 0
		where amt_billed is not null

		-- we'll use a cursor to figure the sales comms
		-- declare it
		declare salescomm_cursor cursor
		for
			select client, proj, date, amt_billed
			from #emp_comm
		for update of salescomm
		-- declare vars we need for the cursor
		-- (we declared @client and @proj up above)
		declare @date datetime, @amt_billed money, @salescomm smallmoney
		-- open it
		open salescomm_cursor
		-- get the first row
		fetch salescomm_cursor
		into @client, @proj, @date, @amt_billed
		-- start the loop
		while (@@sqlstatus = 0)
		begin
			if @amt_billed > 0
			begin
				-- general client sales commissions
				select @salescomm = (
					select sum(@amt_billed * sc.commission_pct / 100.0)
					from sales_commission sc
					where sc.client = @client
					and sc.proj is NULL
					and @date between sc.start_date and sc.end_date
				)
				-- update the salescomm
				if @salescomm > 0
				begin
					update #emp_comm
					set salescomm = @salescomm
					where current of salescomm_cursor
				end
				-- project specific sales commissions
				select @salescomm = sum(@amt_billed * sc.commission_pct / 100.0)
				from sales_commission sc
				where sc.client = @client
				and sc.proj = @proj
				and @date between sc.start_date and sc.end_date
				-- update the salescomm
				if @salescomm > 0
				begin
					update #emp_comm
					set salescomm = @salescomm
					where current of salescomm_cursor
				end
			end
			-- get the next row
			fetch salescomm_cursor
			into @client, @proj, @date, @amt_billed
		end
		-- close it
		close salescomm_cursor
	go

	grant execute on billing_amounts to public
	go

	-- stored procedure to figure employee commission: this one
	-- calls billing_amounts (the other proc)
	drop procedure emp_commission
	go

	create procedure emp_commission
	as
		-- things that don't get paid have no employee comm
		update #emp_comm
		set payrate = 0, amt_paid = 0, empcomm = 0
		from #emp_comm ec, project p, project_type pt
		where ec.client = p.client
		and ec.proj = p.proj
		and p.proj_type = pt.proj_type
		and pt.requires_payment = 0
		-- blank employee is special signal that this came from
		-- some table other than log (and thus gets no employee comm)
		update #emp_comm
		set payrate = 0, empcomm = 0
		from #emp_comm ec
		where ec.emp = ''

		-- if we have any training classes in here, we'll figure
		-- employee commission based on *all* work done for the
		-- corresponding project ... so let's get those entries now
		-- (we use a special source_tbl value so we can find them later)
		-- since you don't know the total profit until the training
		-- project is officially done, we'll skip any rows where the
		-- project is "open" (i.e., the end_date is still END_OF_TIME)
		insert #emp_comm
			(source_tbl, source_id, emp, client, proj, date, hours, billrate)
		select 'training work', l.id, l.emp, l.client, l.proj, l.date,
				l.hours, 0.0
		from log l, project p, project_type pt
		where l.client = p.client
		and l.proj = p.proj
		and p.proj_type = pt.proj_type
		and pt.use_training_rates = 1
		and l.date between p.start_date and p.end_date
		and p.end_date != $END_OF_TIME
		and exists
		(
			select 1
			from #emp_comm ec
			where l.client = ec.client
			and l.proj = ec.proj
		)

		-- now figure out pay rates
		-- general employee rates
		update #emp_comm
		set payrate = pr.rate, paytype = pr.rate_type
		from #emp_comm ec, pay_rate pr
		where ec.payrate is NULL
		and ec.emp = pr.emp
		and pr.client is NULL
		and pr.proj is NULL
		and ec.date between pr.start_date and pr.end_date
		-- client specific employee rates
		update #emp_comm
		set payrate = pr.rate, paytype = pr.rate_type
		from #emp_comm ec, pay_rate pr
		where ec.emp = pr.emp
		and ec.client = pr.client
		and pr.proj is NULL
		and ec.date between pr.start_date and pr.end_date
		-- client and project specific employee rates
		update #emp_comm
		set payrate = pr.rate, paytype = pr.rate_type
		from #emp_comm ec, pay_rate pr
		where ec.emp = pr.emp
		and ec.client = pr.client
		and ec.proj = pr.proj
		and ec.date between pr.start_date and pr.end_date

		-- but subcontractors don't get employee comm
		update #emp_comm
		set empcomm = 0
		where paytype = 'S'

		-- figuring billing amounts is sort of tricky, so
		-- it has its own stored procedure
		execute billing_amounts

		-- if, after that, the bill rates still aren't there, no emp comm
		update #emp_comm
		set empcomm = 0
		where billrate = 0
		 
		-- figure amount paid (simple multiplication)
		update #emp_comm
		set amt_paid = payrate * hours
		where payrate > 0
		and amt_paid is null

		-- referral commissions aren't so tough
		-- (but things that don't get paid also don't get ref comm)
		update #emp_comm
		set refcomm = rc.commission * ec.hours
		from #emp_comm ec, referral_commission rc
		where ec.emp = rc.emp
		and ec.date between rc.start_date and rc.end_date
		and ec.amt_paid > 0

		-- now get totals for any training projects
		-- first, totals for paid out
		insert #emp_comm
			(source_tbl, emp, client, proj, date, hours,
					amt_paid, refcomm)
		select 'training intermediate', ec.emp, ec.client, ec.proj,
				p.end_date, sum(ec.hours),
				sum(ec.amt_paid), sum(ec.refcomm)
		from #emp_comm ec, project p, project_type pt
		where ec.source_tbl = 'training work'
		and ec.client = p.client
		and ec.proj = p.proj
		and p.proj_type = pt.proj_type
		and pt.use_training_rates = 1
		group by ec.emp, ec.client, ec.proj, p.end_date
		-- gotta save total hours in a temp table
		create table #training_total_paid
		(
			client			char(3)			NOT NULL,
			proj			char(3)			NOT NULL,
			total_hours		numeric(6,2)	NOT NULL,
			total_paid		money			NOT NULL,
		)
		insert #training_total_paid
		select ec.client, ec.proj, sum(ec.hours), sum(ec.amt_paid)
		from #emp_comm ec
		where ec.source_tbl = 'training intermediate'
		and ec.emp != ''
		group by ec.client, ec.proj
		-- now totals for billed out
		insert #emp_comm
			(source_tbl, emp, client, proj, date, hours,
					amt_billed, salescomm)
		select 'training intermediate', '', ec.client, ec.proj, p.end_date, 0,
				sum(ec.amt_billed), sum(ec.salescomm)
		from #emp_comm ec, project p, project_type pt
		where ec.source_tbl = 'training_class'
		and ec.client = p.client
		and ec.proj = p.proj
		and p.proj_type = pt.proj_type
		and pt.use_training_rates = 1
		group by ec.client, ec.proj, p.end_date
		/*
		-- and get the total paid from our temp table
		-- (this is technically unnecessary--comment out unless debugging)
		update #emp_comm
		set hours = ttp.total_hours, amt_paid = ttp.total_paid
		from #emp_comm ec, #training_total_paid ttp
		where ec.source_tbl = 'training intermediate'
		and ec.emp = ''
		and ec.client = ttp.client
		and ec.proj = ttp.proj
		*/
		-- now put 'em together (ec1 is total billed, ec2 is total paid)
		-- note that the ec2.amt_paid / ttp.total_paid just gives a convenient
		-- percentage to apply to total billed amounts
		-- also note we assign a paytype (otherwise payroll query kicks it out)
		insert #emp_comm
			(source_tbl, emp, client, proj, date, hours, paytype,
					amt_paid, refcomm, amt_billed, salescomm)
		select 'training total', ec2.emp, ec1.client, ec1.proj, ec1.date,
				ec2.hours, 'T', ec2.amt_paid, ec2.refcomm,
				ec1.amt_billed * (convert(real, ec2.amt_paid) / ttp.total_paid),
				ec1.salescomm * (convert(real, ec2.amt_paid) / ttp.total_paid)
		from #emp_comm ec1, #emp_comm ec2, #training_total_paid ttp
		where ec1.source_tbl = 'training intermediate'
		and ec1.emp = ''
		and ec2.source_tbl = 'training intermediate'
		and ec2.emp != ''
		and ec1.client = ec2.client
		and ec1.proj = ec2.proj
		and ec2.client = ttp.client
		and ec2.proj = ttp.proj
		-- have to get rid of intermediate steps, because they look like errors
		-- (comment this part out when debugging)
		delete #emp_comm
		where source_tbl = 'training intermediate'
		-- have to get rid of work rows, because they look like payroll
		-- (comment this part out when debugging too)
		delete #emp_comm
		where source_tbl = 'training work'

		-- get gross take (simple subtraction)
		update #emp_comm
		set gross = amt_billed - salescomm - refcomm
		where empcomm is NULL

		-- get diff (also simple subtraction)
		update #emp_comm
		set diff = amt_billed - salescomm - refcomm - amt_paid
		--where empcomm is NULL

		-- employee commission before magic date 9/7/98 is easy
		update #emp_comm
		set empcomm = diff * .04
		where empcomm is NULL
		and date < '9/7/98' 
		 
		-- after that, it gets bitchier:
		declare @rate_factor real, @breakeven_factor real, @flare_factor real
		select @rate_factor = 12.0
		select @breakeven_factor = 3.0
		select @flare_factor = 20.0
		update #emp_comm
		set empcomm = convert(money, 
		 		diff * diff / (
					(gross / @rate_factor) -
							(diff - gross / @breakeven_factor) / @flare_factor
				) / 100.0
			)
		where empcomm is NULL
	go

	grant execute on emp_commission to public
	go

END
