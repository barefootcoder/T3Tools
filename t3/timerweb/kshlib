#!/bin/ksh

#	$Header$

# This file originally begun
# July 18, 1997
# (long time ago, eh?)
# by Buddy Burden

# this is a library of ksh functions and constants designed to be
# called from ksh scripts by "dotting" in this script
# (i.e., . /usr/local/bin/kshlib at the top of your script)


# constants

	# general stuff
	readonly me=${0##*/}							# slightly prettier than $0

	# date stuff
	readonly BEGINNING_OF_TIME="'1/1/1753'"			# according to Sybase docs
	readonly END_OF_TIME="'12/31/9999'"				# ditto
		# these are for the "smalldatetime" type
	readonly SMALL_BEGINNING_OF_TIME="'1/1/1900'"
	readonly SMALL_END_OF_TIME="'12/6/2079'"
		# the "first" Barefoot date
		# (this is day 1 of the very first pay period known to Barefoot)
	readonly BAREFOOT_EPOCH="'1/31/1994'"


############################################################################
###                     input / display utilities                        ###
############################################################################

function get_return
{
	echo
	read return?"Press return to continue: "
}


############################################################################
###                          file utilities                              ###
############################################################################

function blank_file
{
	file=$1

	if [ -e $file ]
	then
		/bin/rm -f $file
	fi
	touch $file
}

function remove_sp_returns
{
	# designed to be used as a filter which will remove those
	# annoying "return status = 0" lines without overbuffering your
	# SQL output so it takes forever to see what's going on
	perl -ne '
		BEGIN	{ $| = 1; }			# causes perl to autoflush
		print unless /^\(return status = 0\)$/;
	'
}

function remove_bcp_rows
{
	# designed to be used as a filter which will remove those
	# annoying "1000 lines copied" lines without overbuffering your
	# bcp output so it takes forever to see what's going on
	perl -ne '
		BEGIN	{ $| = 1; }			# causes perl to autoflush
		print unless /^1000 rows successfully bulk-copied to host-file\.$/;
	'
}

function bcp_file
{
	# variables server and user are expected to be set before calling
	db=$1
	table=$2
	file=$3
	direction=$4					# "in" or "out"
	fmtfile=$5						# this is optional, or can be "FIXED"

	if [ -z "$db" -o -z "$table" -o -z "$file" -o -z "$direction" ]
	then
		echo "bcp_file: missing argument" >&2
		return
	fi
	if [ -z "$server" -o -z "$user" ]
	then
		echo "bcp_file: server and user must be set before calling" >&2
		return
	fi

	bcp_input=$(sybpasswd $server $user)			# start with password

	if [ -z "$fmtfile" ]
	then
		format="-c"
	elif [ "$fmtfile" = "FIXED" ]
	then
		bcp_input="$bcp_input\n"					# add a newline first

		# we need to build an input string, one set of values for each field
		colquery="select name from syscolumns where id = object_id('$table')"
		for field in $(get_sql "$colquery" -S$server -U$user -D$db)
		do
			# 1st \n: type, 0 and 2nd \n: prefix length, 3rd \n: field
			# length, 4th \n: field separator (should default to [none])
			bcp_input="$bcp_input\n0\n\n\n"
		done
		# lastly, add a "n" to cover the "do you want to save format file?"
		bcp_input="${bcp_input}n"
		# don't really need a format now
		format=
	else
		format="-f $fmtfile"
	fi

	echo "$bcp_input" | bcp $db..$table $direction $file -S$server -U$user	\
			$format | grep -v '^Password: *$'
}


############################################################################
###                           SQL utilities                              ###
############################################################################

function printdate
{
	message=$1

	cat <<-END

		declare @date char(20)
		set nocount on
		select @date = getdate()
		set nocount off
		print @date
		print '$message'
		go

	END
}

function make_midnight
{
	date=$1

	# if you convert to char and use only the date part (i.e., drop off
	# the hours and minutes), then convert it back to a datetime,
	# it will get a time of midnight automatically
	echo "convert(datetime, convert(char(12), $1, 109))"
}

function zero_fill
{
	column=$1
	typeset -i length=$2

	if [ $length -eq 0 ]
	then
		echo "zero_fill: need non-zero length" >&2
		return
	fi

	echo "right(rtrim(replicate('0', $((length - 1)) ) \c"
	echo "+ convert(char($length), $column)), $length)"
}

function right_justify
{
	column=$1
	typeset -i length=$2

	if [ $length -eq 0 ]
	then
		echo "right_justify: need non-zero length" >&2
		return
	fi

	echo "right(rtrim(space( $((length - 1)) ) \c"
	echo "+ convert(char($length), $column)), $length)"
}

function round
{
	column=$1				# what you want to round
	round_to=$2				# arbitrary number to round to (e.g., .25)
	direction=$3			# "U" for up, "D" for down, "O" for off
	# note that unlike most arguments to these SQL functions, direction
	# must be a literal (i.e., can't be a column containg 'U' or whatever)

	case $direction in
		U)	echo "ceiling(($column) / convert(real, $round_to)) * $round_to"
			;;
		D)	echo "floor(($column) / convert(real, $round_to)) * $round_to"
			;;
		O)	echo "round(($column) / convert(real, $round_to), 0) * $round_to"
			;;
		*)	echo "round: invalid direction specified" >&2
			;;
	esac
}

function overwrite_table
{
	table=$1
	fields=$2

	if [ -z "$table" -o -z "$fields" ]
	then
		echo "overwrite_table: missing argument" >&2
		return
	fi

	cat <<-END

		if object_id('$table') is not NULL drop table $table
		go
		create table $table ($fields)
		go
		grant select on $table to public
		go

	END
}

function drop_procedure
{
	procedure=$1

	if [ -z "$procedure" ]
	then
		echo "drop_procedure: missing argument" >&2
		return
	fi

	cat <<-END

		if exists
		(
			select 1
			from sysobjects
			where name = '$procedure'
			and type = 'P'
		)
		drop procedure $procedure
		go

	END
}

function copy_structure
{
	from_table=$1
	to_table=$2

	if [ -z "$from_table" -o -z "$to_table" ]
	then
		echo "copy_structure: missing argument" >&2
		return
	fi

	cat <<-END

		if object_id('$to_table') is not NULL drop table $to_table
		go
		set nocount on
		select *
		into $to_table
		from $from_table
		where 1 = 0
		set nocount off
		go
		grant select on $to_table to public
		go

	END
}


############################################################################
###                     TIMER specific SQL utilities                     ###
############################################################################

# gives the employee first name, with last initial if show_last is turned on
function employee_name
{
	table_alias=$1		# most commonly, "e"

	echo "rtrim($table_alias.fname) + ' ' + \c"
	echo "substring($table_alias.lname, $table_alias.show_last, 1)"
}

# builds the table that calc_pay_amount uses
# (this is called by build_profit_item)
function build_pay_amount
{
	where_clause=$1

	if [ -z "$where_clause" ]
	then
		# do everything
		where_clause="1 = 1"
	fi

	cat <<-END

		set nocount on
		go

		-- clear out old stuff
		delete pay_amount

		-- put in the new
		insert pay_amount
			(log_source, log_id, emp, client, proj, phase, date, hours,
					requires_payment)
		select log.log_source, log.log_id, log.emp, log.client, log.proj,
				log.phase, log.date, log.hours, pt.requires_payment
		from time_log log, project p, project_type pt
		where $where_clause
		and log.client = p.client
		and log.proj = p.proj
		and log.date between p.start_date and p.end_date
		and p.proj_type = pt.proj_type

		go

		set nocount off
		go

	END
}

# builds the tables that calc_profit and its cousins use
function build_profit_item
{
	# in the where clause, you should use "log" as the alias to refer
	# to columns from the log table (which could be any of the three)
	where_clause=$1

	if [ -z "$where_clause" ]
	then
		# do everything
		where_clause="1 = 1"
	fi

	# have to call build_pay_amount too
	build_pay_amount "$where_clause"

	# in order to handle projects which demand profit calculated at
	# the end of the project, we'll have to substitute the project end
	# date for any requests on the log date
	# (if no requests on the log date were made, that's okay too)
	end_profit_where_clause="$(echo "$where_clause" | perl -pe '
			s/\blog\.date\b/p.end_date/g;
	')"

	# note that we use the same alias (log) for all three of the log tables
	# this enables our clients to refer to the columns no matter which
	# of the three tables we're working on ... of course it also means
	# that they may _not_ refer to a column which is not common to all three
	cat <<-END

		set nocount on
		go

		-- clear out our profit items tables
		delete time_log_profit
		delete profit_item

		-- for time logs, we'll need to fill the time_log_profit table
		-- calc_total_price will later insert them into profit_item
		-- note that we insert a default billing ratio of 1
		-- (this could get overridden later by calc_total_price)

		-- first, get time logs that will be one profit item each
		insert time_log_profit
			(log_source, log_id, emp, client, proj, phase, date, hours,
					start_date, end_date, requires_payment,
					resource_billing, class_billing, billing_ratio, sum_by_proj)
		select log.log_source, log.log_id, log.emp, log.client, log.proj,
				log.phase, log.date, log.hours, log.date, log.date,
				pt.requires_payment, pt.resource_billing,
				pt.class_billing, 1, 0
		from time_log log, project p, project_type pt
		where $where_clause
		and log.client = p.client
		and log.proj = p.proj
		and log.date between p.start_date and p.end_date
		and p.proj_type = pt.proj_type
		and pt.requires_billing = 1
		and pt.no_profit_till_end = 0

		-- next, get time logs that will be summed
		-- into one profit item per project
		insert time_log_profit
			(log_source, log_id, emp, client, proj, phase, date, hours,
					start_date, end_date, requires_payment,
					resource_billing, class_billing, billing_ratio, sum_by_proj)
		select log.log_source, log.log_id, log.emp, log.client, log.proj,
				log.phase, log.date, log.hours, p.start_date, p.end_date,
				pt.requires_payment, pt.resource_billing,
				pt.class_billing, 1, 1
		from time_log log, project p, project_type pt
		where $end_profit_where_clause
		and log.client = p.client
		and log.proj = p.proj
		and log.date between p.start_date and p.end_date
		and p.proj_type = pt.proj_type
		and pt.requires_billing = 1
		and pt.no_profit_till_end = 1

		-- the remainder we can insert directly into profit_item ourselves

		-- now insert relevant materials logs
		-- (they're pretty easy, even though there's three "types" of them)
		-- STEP 1: materials logs with no project
		insert profit_item
			(client, proj, start_date, end_date, log_source, log_id, units,
					price_per_unit)
		select client, proj, date, date, log_source, log_id, 1, amount_billed
		from materials_log log
		where $where_clause
		and proj is null
		-- STEP 2: materials logs for projects with "now" profit calculation
		insert profit_item
			(client, proj, start_date, end_date, log_source, log_id, units,
					price_per_unit)
		select log.client, log.proj, log.date, log.date,
				log.log_source, log.log_id, 1, log.amount_billed
		from materials_log log, project p, project_type pt
		where $where_clause
		and log.client = p.client
		and log.proj = p.proj
		and p.proj_type = pt.proj_type
		and pt.requires_billing = 1
		and pt.no_profit_till_end = 0
		-- STEP 3: materials logs for projects with "at end" profit calculation
		insert profit_item
			(client, proj, start_date, end_date, log_source, log_id, units,
					price_per_unit)
		select log.client, log.proj, log.date, log.date,
				log.log_source, log.log_id, 1, log.amount_billed
		from materials_log log, project p, project_type pt
		where $end_profit_where_clause
		and log.client = p.client
		and log.proj = p.proj
		and p.proj_type = pt.proj_type
		and pt.requires_billing = 1
		and pt.no_profit_till_end = 1

		-- get class logs that are one item per class
		insert profit_item
			(client, proj, start_date, end_date, log_source, log_id, units,
					price_per_unit)
		select log.client, log.proj, log.date, log.date, log_source, log_id,
				datediff(minute, log.start_time, log.end_time) / 60.0
						- (isnull(log.num_breaks, 0) * .25),
				log.num_students * br.rate
		from class_log log, project p, project_type pt, bill_rate br
		where $where_clause
		and log.client = p.client
		and log.proj = p.proj
		and log.date between p.start_date and p.end_date
		and p.proj_type = pt.proj_type
		and pt.requires_billing = 1
		and pt.no_profit_till_end = 0
		and log.client = br.client
		and log.proj = br.proj
		and log.date between br.start_date and br.end_date

		-- get class logs that are "full project" quantities
		insert profit_item
			(client, proj, start_date, end_date, log_source, units,
					price_per_unit)
		select log.client, log.proj, p.start_date, p.end_date, 'class_log SUM',
				1, sum((datediff(minute, log.start_time, log.end_time) / 60.0
						- (isnull(log.num_breaks, 0) * .25))
						* log.num_students * br.rate)
		from class_log log, project p, project_type pt, bill_rate br
		where $end_profit_where_clause
		and log.client = p.client
		and log.proj = p.proj
		and p.proj_type = pt.proj_type
		and pt.requires_billing = 1
		and pt.no_profit_till_end = 1
		and log.client = br.client
		and log.proj = br.proj
		and log.date between br.start_date and br.end_date
		group by log.client, log.proj, p.start_date, p.end_date

		-- now a slightly tricky part ... we'll need to get any time logs
		-- that apply to the class logs, so that profit can be calculated
		-- appropriately ... of course, there's always the possibility that
		-- they're already there, so we have to be careful
		insert time_log_profit
			(log_source, log_id, emp, client, proj, phase, date, hours,
					start_date, end_date, requires_payment,
					resource_billing, class_billing, billing_ratio, sum_by_proj)
		select log.log_source, log.log_id, log.emp, log.client, log.proj,
				log.phase, log.date, log.hours, log.date, log.date,
				pt.requires_payment, pt.resource_billing,
				pt.class_billing, 1, 0
		from profit_item pi, time_log log, project p, project_type pt
		where pi.log_source like 'class_log%'
		and pi.client = log.client
		and pi.proj = log.proj
		and log.date between pi.start_date and pi.end_date
		and log.client = p.client
		and log.proj = p.proj
		and p.proj_type = pt.proj_type
		and not exists
		(
			select 1
			from time_log_profit tlp
			where log.log_source = tlp.log_source
			and log.log_id = tlp.log_id
		)

		go

		set nocount off
		go

	END
}


# the period functions are designed to make it easy to figure out what
# week (7-day period) you're in, and what the beginning of the week is, and
# stuff like that ... of course, it works well for other things too (e.g.,
# fixed-price contracts where you bill every two weeks or payroll periods,
# which are also two weeks; just use a 14-day period and you can figure out
# the period begin/end dates given any date within the period)

function period_num
{
	date="$1"				# the date to find the period number for
	period_len="$2"			# how many days a period is

	echo "(datediff(day, $BAREFOOT_EPOCH, $date) / $period_len)"
}

function period_day
{
	date="$1"				# the date you want to know the day number for
	period_len="$2"			# how many days a period is

	echo "datediff(day, $BAREFOOT_EPOCH, $date) % $period_len"
}

function period_date
{
	period_num="$1"			# the period number (probably from period_num)
	day_number="$2"			# which day w/in the period (prob. from period_day)
	period_len="$3"			# how many days a period is

	echo "dateadd(day, $period_num * $period_len + $day_number, \c"
	echo "$BAREFOOT_EPOCH)"
}

function period_start		# same as $(period_date num 0 len)
{
	period_num="$1"			# the period number (probably from period_num)
	period_len="$2"			# how many days a period is

	echo "dateadd(day, $period_num * $period_len, $BAREFOOT_EPOCH)"
}

function period_end			# same as $(period_date num $((len - 1)) len)
{
	period_num="$1"			# the period number (probably from period_num)
	period_len="$2"			# how many days a period is

	echo "dateadd(day, $period_num * $period_len + $period_len - 1, \c"
	echo "$BAREFOOT_EPOCH)"
}

function period_name		# a string that describes the period
{
	period_num="$1"			# the period number (probably from period_num)
	period_len=$2			# how many days a period is

	echo "convert(char(10), $(period_start "$period_num" $period_len), 101) \c"
	echo "+ ' to ' + \c"
	echo "convert(char(10), $(period_end "$period_num" $period_len), 101)"
}

function in_period_range
{
	date="$1"				# date to check
	period_num="$2"			# the period number (probably from period_num)
	period_len=$3			# how many days a period is

	echo "$date between $(period_start "$period_num" $period_len) \c"
	echo "and $(period_end "$period_num" $period_len)"
}
