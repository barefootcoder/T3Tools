#! /usr/bin/perl -w

# For CVS:
# $Date$
#
# $Id$
# $Revision$

use strict;

#use Barefoot::debug(1);

use Getopt::Std;
use Tie::IxHash;
use Date::Parse;
use Data::Dumper;
use Time::ParseDate;

use Barefoot::base;
use Barefoot::date;
use Barefoot::array;
use Barefoot::range;
use Barefoot::format;
use Barefoot::exception;
use Barefoot::input qw<input get_yn menu_select>;

use Barefoot::T3::base;
use Barefoot::T3::valid qw<get_parameter>;
use Barefoot::T3::db_get qw<one_datum>;


#################################
# CONSTANTS
#################################

use constant PRESS_RETURN => "Press return to continue . . .";


#################################
# FORMATS
#################################

use constant TodoListHeader =>
"   Todo:       Description:                              CLI PRJ  Due by:\n" .
"   ==========  ========================================  === ===  ========";

use constant TodoList =>
'   @<<<<<<<<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  @<< @<<  @m/#d/@y';

use constant TodoTask =>
	'
    Client:      @<<      @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<      Date:
    Project:     @<<      @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<      @m/#d/@yyy
    Phase:       @<<      @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    Tracking: @<<<<<<<<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    Description:  ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<&
    ~~            ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<';


#################################
# OPTIONS AND ENVIRONMENT VARS
#################################

our $parminfo = {};

if (-t STDOUT or @ARGV)
{
	my $opt = {};
	getopts('fhu:', $opt) or usage();
	$parminfo->{noconfirm} = defined $opt->{f};
	$parminfo->{user} = $opt->{u};

	usage() if defined $opt->{h};
}
else
{
}


#################################
# PSEUDO-GLOBAL VARIABLES
#################################

our (@todo_list, %todo_index);

our %menu_list;
tie %menu_list, 'Tie::IxHash',
(
	"Add a task"			=>		\&add_todo,
	"Show task details"		=>		\&todo_details,
	"Edit a task"			=>		\&edit_todo,
	"Cancel a task"			=>		\&cancel_todo,
	"Complete a task"		=>		\&complete_todo,
	"Refresh task list"		=>		\&refresh_list,
	"Quit program"			=>		sub { exit },
);

# this is a primitive way to get this, but it works
my ($screen_rows) = split(' ', `stty size`);
# now figure maximum number of tasks we can put in our list:
# save 2 rows for list header, 1 for separator between list and menu,
# the number of menu items, and 2 for the prompt after the menu
our $max_task_list = $screen_rows - 2 - 1 - scalar(keys %menu_list) - 2;


#################################
# main()
#################################

initialize();

# infinite loop for menu and actions
while (true)
{
	show_todos();
	my @menu_choices = keys %menu_list;
	my $command = menu_select("Choose:", @menu_choices);
	$menu_list{ $menu_choices[$command] }->();
}


#################################
# MENU COMMAND SUBROUTINES
#################################


sub add_todo
{
	my $new_todo = {};

	$new_todo->{name} = input("Short codename for the item:");
	if (exists $todo_index{$new_todo->{name}})
	{
		print "There is already a task with that code; sorry.\n";
		input(PRESS_RETURN);
		return undef;
	}
	input_todo($new_todo);

	push @todo_list, $new_todo and sync_lists();
	writefile();
}


sub todo_details
{
	my $index = get_existing_todo("show details for");
	return unless defined $index;
	input(PRESS_RETURN);
}


sub edit_todo
{
	my $index = get_existing_todo("edit");
	return unless defined $index;

	input_todo($todo_list[$index]);

	sync_lists();
	writefile();
}


sub cancel_todo
{
	my $index = get_existing_todo("cancel");
	return unless defined $index;

	print "A cancelled todo task is gone forever!!\n";
	if (get_yn("Are you sure you want to do this?"))
	{
		my $old_todo = splice @todo_list, $index, 1;
		sync_lists();
		save_history($parminfo->{user}, "cancel", todo_fields($old_todo));
		writefile();
	}
}


sub complete_todo
{
	my $index = get_existing_todo("complete");
	return unless defined $index;

	if (get_yn("Are you definitely ready to mark this task completed?"))
	{
		my $old_todo = splice @todo_list, $index, 1;
		sync_lists();
		save_history($parminfo->{user}, "complete", todo_fields($old_todo));
		writefile();
	}
}


sub refresh_list
{
	# clear the list, then reread the file: that refreshes the list
	undef @todo_list;
	readfile();
}


#################################
# SUBROUTINES
#################################

sub usage
{
	error(0, "usage is:\n",
			"    todo [-h | -f]\n",
			"       -h: this help message\n",
			"       -f: don't ask for confirmations\n",
	);
}


sub error
{
	my ($exitcode, @messages) = @_;
	my $progname = $0;
	$progname =~ s@.*/@@;
=comment
	if ($cgi)
	{
		foreach (@messages)
		{
			# s/\n/<BR>\n/g;
		}
		print @messages, "\n";
		exit 0;
	}
	else
=cut
	{
		print STDERR "$progname: ", @messages, "\n";
		exit $exitcode;
	}
}


sub initialize
{
	$parminfo->{user} ||= t3_username();

	readfile();
}


sub readfile
{
	open(IN, T3::base_filename(TODO => $parminfo->{user}))
			or die("can't read todo file");
	while ( <IN> )
	{
		chomp;

		my $todo = {};
		(todo_fields($todo)) = split("\t");

		# account for the possibility that due dates are stored as
		# date strings instead of time numbers (as they should be)
		$todo->{due} = str2time($todo->{due}) if $todo->{due} =~ m@/@;

		push @todo_list, $todo;
	}
	close(IN);

	sync_lists();
}


sub writefile
{
	open(OUT, ">" . T3::base_filename(TODO => $parminfo->{user}))
			or die("can't write todo file");
	foreach my $todo (@todo_list)
	{
		print OUT join("\t", todo_fields($todo)), "\n";
	}
	close(OUT);
}


# this keeps %todo_index sync'ed up with @todo_list.  you have to call
# this function yourself every time you modify @todo_list.

sub sync_lists
{
	%todo_index = map { $todo_list[$_]->{name} => $_ } 0..$#todo_list;
}


sub show_todos
{
	if (@todo_list)
	{
		# sort list and truncate if too long to fit on screen
		my @disp_list = sort { $a->{due} <=> $b->{due} } @todo_list;
		my $more = false;
		if (@disp_list > $max_task_list)
		{
			# use max number - 1 to account for "more" line
			splice @disp_list, $max_task_list - 1;
			$more = true;
		}

		print "\n", TodoListHeader, "\n";
		foreach my $todo (@disp_list)
		{
			writeln(TodoList, todo_fields($todo));
		}
		print "<<MORE TASKS THAN SHOWN>>\n" if $more;
		print "\n";
	}
	else
	{
		print "\n\tYou have no items in your todo list.\n\n";
	}
}


sub get_existing_todo
{
	my ($operation) = @_;

	my $name = input("What is the name of the task you want to $operation?");

	unless (exists $todo_index{$name})
	{
		print "No such task!\n";
		input(PRESS_RETURN);
		return undef;
	}

	my $todo = $todo_list[$todo_index{$name}];

	# retrieve full names from database
	foreach (
			[ "client",		"{~timer}.client",			"client_id",	false ],
			[ "project",	"{~timer}.project",			"proj_id",		true ],
			[ "phase",		"{~timer}.phase",			"phase_id",		false ],
			[ "tracking",	"{~timer}.client_tracking",	"tracking_code",true ],
			)
	{
		my ($which, $table, $id_col, $use_client) = @$_;

		# it's okay if the element is missing; just blank out and move on
		if (not $todo->{$which})
		{
			$todo->{$which} = $todo->{"${which}_name"} = "";
			next;
		}

		my $query = "
				select name from $table
				where $id_col = '$todo->{$which}'
			";
		$query .= " and client_id = '$todo->{client}'" if $use_client;

		$todo->{"${which}_name"} = one_datum($query);
	}

	# make a copy for the format, else the field itself will get eaten
	my $descr = $todo->{descr};
	writeln(TodoTask, @$todo{ qw<client client_name project project_name
			due phase phase_name tracking tracking_name> }, $descr);
	print "\n\n";

	return $todo_index{$name};
}


sub input_todo
{
	my ($todo) = @_;

	$todo->{descr} = input("Brief description of the task:", $todo->{descr});
	$todo->{due} = input(
			"When task is due:",
			$todo->{due} ? swrite('@m/#d/@y', $todo->{due}) : date::today(), 
			{
				VALID		=>	\&valid_date_input,
				VALID_ERR	=>	"\a\a  >>Invalid Date!\n"
			}
	);
	# turn due date into a number
	if ($todo->{due} =~ /^\+(\d+)$/)
	{
		# interpret as number of days from today
		$todo->{due} = date::incDays(date::today(), $1);
	}
	elsif ($todo->{due} =~ /^[A-Za-z]{3}$/)
	{
		# interpret as a 3-char abbrev for day of week (in the future)
		$todo->{due} = date::mdy(parsedate($todo->{due}, PREFER_FUTURE => 1));
	}
	$todo->{due} = str2time($todo->{due});

	# need to save results in object, not parminfo
	my $opts = { SAVE_IN_OBJECT => 1 };
	get_parameter("client", $parminfo, $todo, $opts);
	get_parameter("project", $parminfo, $todo, $opts);
}


BEGIN
{
	# this ought to go in date.pm, but I'm too lazy right now ...
	my @DoW = qw< sun mon tue wed thu fri sat >;
	our %DoW = map { ($DoW[$_] => $_) } (0..$#DoW);

	sub valid_date_input
	{
		# valid day of week abbreviation
		return true if exists $DoW{ lc $_[0] };

		# '+' and number of days offset
		return true if $_[0] =~ /^\+\d+$/;

		# allow just month/date
		# supply year such that resulting date is always in the future
		# after adjusting our parameter, it will be verified by isValid below
		if (my ($month, $day) = $_[0] =~ m@^(\d+)[/.-](\d+)$@)
		{
			my ($this_month, $this_date, $this_year)
					= split('/', date::today());
			if ($month == $this_month)
			{
				if ($day < $this_date)
				{
					$_[0] = "$month/$day/" . ($this_year + 1);
				}
				else			# must be $day >= $this_date
				{
					$_[0] = "$month/$day/$this_year";
				}
			}
			elsif ($month < $this_month)
			{
				$_[0] = "$month/$day/" . ($this_year + 1);
			}
			else				# must be $month > $this_month
			{
				$_[0] = "$month/$day/$this_year";
			}
		}

		# valid date is okay, obviously
		return true if date::isValid($_[0]);

		# no hits so far, must be bogus
		return false;
	}
}


sub save_history
{
	my ($user, $command, @todo_fields) = @_;

	my $file = T3::hist_filename(TODO => $user);
	open(HIST, ">>$file") or die("can't open history file $file");
	print HIST join("\t", $ENV{USER}, date::today(), $command, $user,
			@todo_fields), "\n";
	close(HIST);
}
