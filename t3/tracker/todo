#! /usr/bin/perl

###########################################################################
#
# todo
#
###########################################################################
#
# First working Tracker module.
#
# #########################################################################
#
# All the code herein is released under the Artistic License
#		( http://www.perl.com/language/misc/Artistic.html )
# Copyright (c) 2002-2003 Barefoot Software, Copyright (c) 2004-2006 ThinkGeek
#
###########################################################################

use strict;
use warnings;

#use Barefoot::debug(1);

use Getopt::Std;
use Tie::IxHash;
use Date::Parse;
use Data::Dumper;
use Time::ParseDate;

use Barefoot::base;
use Barefoot::date;
use Barefoot::array;
use Barefoot::range;
use Barefoot::format;
use Barefoot::exception;
use Barefoot::input qw< input get_yn menu_select $COLS $ROWS >;

use Barefoot::T3::base;
use Barefoot::T3::db_get qw< one_datum >;
use Barefoot::T3::valid qw< get_parameter >;
use Barefoot::T3::CLI qw< cli_common_opts cli_get_command cli_fatal >;


#################################
# CONSTANTS
#################################

use constant PRESS_RETURN => "Press return to continue . . .";


#################################
# FORMATS
#################################

our $TodoListHeader =
"   Todo:            Title:                               CLI PRJ  Due by:\n" .
"   ===============  ===================================  === ===  ========";

our $TodoList =
'   @<<<<<<<<<<<<<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  @<< @<<  @m/#d/@y';

# $TodoList was designed for an 80-column screen; adjust the Title field to take up more or less space based
# on the screen width
_screen_width_adjust($TodoListHeader, 'Title: ');						# note that that trailing space is crucial ...
_screen_width_adjust($TodoListHeader, '=' x 35);
_screen_width_adjust($TodoList, '@' . '<' x 34);

our $TodoTask =
	'
    Client:      @<<      @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<      Date:
    Project:     @<<      @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<      @m/#d/@yyy
    Tracking: @<<<<<<<<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    Title:        ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<&
    ~~            ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    Description:
    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
~~  ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<';


#################################
# OPTIONS AND ENVIRONMENT VARS
#################################

our $parminfo = {};
my $commands = {};
tie %$commands, 'Tie::IxHash',
(
	l	=>	"LIST",
);
our $command;

if (-t STDOUT or @ARGV)
{
	my $opt = {};
	getopts('lfu:h', $opt) or usage();
	cli_common_opts($parminfo, $opt);
	$command = cli_get_command($commands, $opt);

	usage() if defined $opt->{'h'};
}
else
{
}


#################################
# PSEUDO-GLOBAL VARIABLES
#################################

our $todos = {};

our %menu_list;
tie %menu_list, 'Tie::IxHash',
(
	"Add a task"			=>		\&add_todo,
	"Show task details"		=>		\&todo_details,
	"Edit a task"			=>		\&edit_todo,
	"Postpone a task"		=>		\&push_date,
	"Cancel a task"			=>		\&cancel_todo,
	"Done with a task"		=>		\&complete_todo,
	"Refresh task list"		=>		\&refresh_list,
	"Mass postpone tasks"	=>		\&shift_schedule,
	"Quit program"			=>		sub { exit },
);

# the menu will get printed in three columns on an 80-column screen
# sometime in the future, we should try to do this a bit more dynamically,
# but for now this is good enough
my $menu_size = range::round(scalar(keys %menu_list) / 3, range::ROUND_UP);
# now figure maximum number of tasks we can put in our list:
# save 2 rows for list header, 1 for separator between list and menu,
# the number of menu lines, and 2 for the prompt after the menu
our $max_task_list = $ROWS - 2 - 1 - $menu_size - 2;


#################################
# main()
#################################

initialize();

if ($command)
{
	if ($command eq 'LIST')
	{
		print "\n", menu_header(), "\n";
	}

	exit 0;
}
# else no command, so go interactive
$parminfo->{'force'} = 0;

# infinite loop for menu and actions
while (true)
{
	my @menu_choices = keys %menu_list;
	my $mheader = menu_header();
	my $command = menu_select("Choose:", @menu_choices, { LMARGIN => 2, SPBETWEEN => 3, HEADER => $mheader, TMARGIN => 1,
			TRUNC_MSG => "<<MORE TASKS THAN SHOWN>>\n", } );
	$menu_list{ $menu_choices[$command] }->();
}


#################################
# HELPER ROUTINES
#################################

sub _screen_width_adjust
{
	my ($format, $field_to_adj) = @_;

	my $cur_width = length($field_to_adj);
	my $desired_width = $COLS - (80 - $cur_width);
	return if $desired_width == $cur_width;

	my $new_field = $desired_width < $cur_width ? substr($field_to_adj, 0, $desired_width)
			: $field_to_adj . substr($field_to_adj, -1) x ($desired_width - $cur_width);
	$_[0] =~ s/\Q$field_to_adj\E/$new_field/;
}


#################################
# MENU COMMAND SUBROUTINES
#################################


sub add_todo
{
	my $new_todo = {};

	$new_todo->{'name'} = input("Short codename for the item:");
	if (exists $todos->{$new_todo->{'name'}})
	{
		print "There is already a task with that code; sorry.\n";
		input(PRESS_RETURN);
		return undef;
	}
	input_todo($new_todo);

	$todos->{$new_todo->{'name'}} = $new_todo;
	writefile();
}


sub todo_details
{
	my $index = get_existing_todo("show details for");
	return unless defined $index;
	input(PRESS_RETURN);
}


sub edit_todo
{
	my $todo = get_existing_todo("edit");
	return unless defined $todo;

	input_todo($todo);

	writefile();
}


sub push_date
{
	my $todo = get_existing_todo("postpone");
	return unless defined $todo;

	$todo->{'due'} = input_date($todo->{'due'});

	writefile();
}


sub cancel_todo
{
	my $todo = get_existing_todo("cancel");
	return unless defined $todo;

	print "A cancelled todo task is gone forever!!\n";
	if (get_yn("Are you sure you want to do this?"))
	{
		my $old_todo = delete $todos->{$todo->{'name'}};
		save_history($parminfo->{'user'}, "cancel", todo_fields($old_todo));
		writefile();
	}
}


sub complete_todo
{
	my $todo = get_existing_todo("complete");
	return unless defined $todo;

	if (get_yn("Are you definitely ready to mark this task completed?"))
	{
		my $old_todo = delete $todos->{$todo->{'name'}};
		save_history($parminfo->{'user'}, "complete", todo_fields($old_todo));
		writefile();
	}
}


sub refresh_list
{
	# clear the list, then reread the file: that refreshes the list
	$todos = {};
	readfile();
}


sub shift_schedule
{
	# determine oldest task
	my $oldest_todo = (sort( { $a->{'due'} <=> $b->{'due'} } values %$todos))[0];
	my $old_date = $oldest_todo->{'due'};
	writeln('Oldest task is dated @m/#d/@y.', $old_date);

	print "Please enter a new date for this task.\n";
	my $new_date = input_date();

	my $shift_days = int(date::dayDiff($old_date, $new_date));
	print "All tasks will be moved forward $shift_days days.\n";
	if (get_yn("Are you sure?"))
	{
		foreach my $todo (values %$todos)
		{
			$todo->{'due'} = date::dateTimeSeconds(
					date::incDays($todo->{'due'}, $shift_days));
		}

		writefile();
	}
}


#################################
# SUBROUTINES
#################################

sub usage
{
	error(0, "usage is:\n",
			"    todo [-h | -lf -u user]\n",
			"       -h: this help message\n",
			"       -l: list todos and exit (default: enter interactive mode)\n",
			"       -f: don't ask for confirmations in interactive mode\n",
			"       -u: work with todos for a different user\n",
	);
}


sub error
{
	my ($exitcode, @messages) = @_;
	my $progname = $0;
	$progname =~ s@.*/@@;
=comment
	if ($cgi)
	{
		foreach (@messages)
		{
			# s/\n/<BR>\n/g;
		}
		print @messages, "\n";
		exit 0;
	}
	else
=cut
	{
		print STDERR "$progname: ", @messages, "\n";
		exit $exitcode;
	}
}


sub initialize
{
	$parminfo->{'user'} ||= t3_username();

	readfile();
}


sub readfile
{
	$todos = t3_readfile(TODO => $parminfo->{'user'}, {
		FOREACH		=>	sub
						{
							my ($todos, $task) = @_;

							# account for the possibility that due dates are stored as
							# date strings instead of time numbers (as they should be)
							$task->{'due'} = str2time($task->{'due'}) if $task->{'due'} =~ m@/@;
						}
	});
}


sub writefile
{
	return t3_writefile(TODO => $parminfo->{'user'}, $todos);
}


sub todo_menu_list
{
	my @menu_list = sort { $a->{'due'} <=> $b->{'due'} } values %$todos;
	foreach my $todo (@menu_list)
	{
		$todo = swrite($TodoList, todo_fields($todo)) . "\n";
	}
	return @menu_list;
}


sub menu_header
{
	if (%$todos)
	{
		my $list_header = $TodoListHeader . "\n";
		return join('', $list_header, todo_menu_list());
	}
	else
	{
		return "\n\tYou have no items in your todo list.\n\n";
	}
}


sub get_existing_todo
{
	my ($operation) = @_;

	my $name = input("What is the name of the task you want to $operation?");

	unless (exists $todos->{$name})
	{
		print "No such task!\n";
		input(PRESS_RETURN);
		return undef;
	}

	my $todo = $todos->{$name};

	# retrieve full names from database
	foreach (
			[ "client",		"{~timer}.client",			"client_id",	false ],
			[ "project",	"{~timer}.project",			"proj_id",		true ],
			[ "tracking",	"{~timer}.client_tracking",	"tracking_code",true ],
			)
	{
		my ($which, $table, $id_col, $use_client) = @$_;

		# it's okay if the element is missing; just blank out and move on
		if (not $todo->{$which})
		{
			$todo->{$which} = $todo->{"${which}_name"} = "";
			next;
		}

		my $query = "
				select name from $table
				where $id_col = '$todo->{$which}'
			";
		$query .= " and client_id = '$todo->{client}'" if $use_client;

		$todo->{"${which}_name"} = one_datum($query);
	}

	# make a copy for the format, else the field itself will get eaten
	my $title = $todo->{'title'};
	writeln($TodoTask, @$todo{ qw< client client_name project project_name due tracking tracking_name > }, $title);
	print "\n\n";

	return $todo;
}


sub input_todo
{
	my ($todo) = @_;

	$todo->{'title'} = input("Brief description (title) of the task:", $todo->{'title'});
	$todo->{'due'} = input_date($todo->{'due'});

	# need to save results in object, not parminfo
	my $opts = { SAVE_IN_OBJECT => 1 };
	get_parameter("client", $parminfo, $todo, $opts);
	get_parameter("project", $parminfo, $todo, $opts);
}


sub input_date
{
	my ($old_date) = @_;

	my $new_date = input(
			"When task is due:",
			$old_date ? swrite('@m/#d/@y', $old_date) : date::today(), 
			{
				CONVERT		=>	\&parse_date_spec,
				VALID_ERR	=>	"\a\a  >>Invalid Date!\n"
			}
	);

	return $new_date;
}


sub parse_date_spec
{
	# this style needs a little help (but just a little)
	if ($_[0] =~ /^\+(\d+)$/)
	{
		# interpret as number of days from today
		$_[0] .= " days";
	}

	# let parsedate do all the hard work
	return parsedate($_[0], PREFER_FUTURE => 1);
}


sub save_history
{
	my ($user, $command, @todo_fields) = @_;

	my $file = T3::hist_filename(TODO => $user);
	open(HIST, ">>$file") or die("can't open history file $file");
	print HIST join("\t", $ENV{USER}, date::today(), $command, $user,
			@todo_fields), "\n";
	close(HIST);
}
