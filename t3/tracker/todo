#! /usr/bin/perl

# For CVS:
# $Date: 2003/06/26 18:05:57 $
#
# $Id: todo,v 1.7 2003/06/26 18:05:57 buddy Exp $
# $Revision: 1.7 $

use strict;
use warnings;

#use Barefoot::debug(1);

use Getopt::Std;
use Tie::IxHash;
use Date::Parse;
use Data::Dumper;
use Time::ParseDate;

use Barefoot::base;
use Barefoot::date;
use Barefoot::array;
use Barefoot::range;
use Barefoot::format;
use Barefoot::exception;
use Barefoot::input qw<input get_yn menu_select>;

use Barefoot::T3::base;
use Barefoot::T3::valid qw<get_parameter>;
use Barefoot::T3::db_get qw<one_datum>;


#################################
# CONSTANTS
#################################

use constant PRESS_RETURN => "Press return to continue . . .";


#################################
# FORMATS
#################################

use constant TodoListHeader =>
"   Todo:            Description:                         CLI PRJ  Due by:\n" .
"   ===============  ===================================  === ===  ========";

use constant TodoList =>
'   @<<<<<<<<<<<<<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  @<< @<<  @m/#d/@y';

use constant TodoTask =>
	'
    Client:      @<<      @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<      Date:
    Project:     @<<      @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<      @m/#d/@yyy
    Phase:       @<<      @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    Tracking: @<<<<<<<<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    Description:  ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<&
    ~~            ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<';


#################################
# OPTIONS AND ENVIRONMENT VARS
#################################

our $parminfo = {};

if (-t STDOUT or @ARGV)
{
	my $opt = {};
	getopts('fhu:', $opt) or usage();
	$parminfo->{noconfirm} = defined $opt->{f};
	$parminfo->{user} = $opt->{u};

	usage() if defined $opt->{h};
}
else
{
}


#################################
# PSEUDO-GLOBAL VARIABLES
#################################

our (@todo_list, %todo_index);

our %menu_list;
tie %menu_list, 'Tie::IxHash',
(
	"Add a task"			=>		\&add_todo,
	"Show task details"		=>		\&todo_details,
	"Edit a task"			=>		\&edit_todo,
	"Postpone a task"		=>		\&push_date,
	"Cancel a task"			=>		\&cancel_todo,
	"Done with a task"		=>		\&complete_todo,
	"Refresh task list"		=>		\&refresh_list,
	"Mass postpone tasks"	=>		\&shift_schedule,
	"Quit program"			=>		sub { exit },
);

# this is a primitive way to get this, but it works
my ($screen_rows) = split(' ', `stty size`);
# the menu will get printed in three columns on an 80-column screen
# sometime in the future, we should try to do this a bit more dynamically,
# but for now this is good enough
my $menu_size = range::round(scalar(keys %menu_list) / 3, range::ROUND_UP);
# now figure maximum number of tasks we can put in our list:
# save 2 rows for list header, 1 for separator between list and menu,
# the number of menu lines, and 2 for the prompt after the menu
our $max_task_list = $screen_rows - 2 - 1 - $menu_size - 2;


#################################
# main()
#################################

initialize();

# infinite loop for menu and actions
while (true)
{
	my @menu_choices = keys %menu_list;
	my $mheader = menu_header();
	my $command = menu_select("Choose:", @menu_choices,
			{ LMARGIN => 2, SPBETWEEN => 3, HEADER => $mheader, TMARGIN => 1,
					TRUNC_MSG => "<<MORE TASKS THAN SHOWN>>\n", } );
	$menu_list{ $menu_choices[$command] }->();
}


#################################
# MENU COMMAND SUBROUTINES
#################################


sub add_todo
{
	my $new_todo = {};

	$new_todo->{name} = input("Short codename for the item:");
	if (exists $todo_index{$new_todo->{name}})
	{
		print "There is already a task with that code; sorry.\n";
		input(PRESS_RETURN);
		return undef;
	}
	input_todo($new_todo);

	push @todo_list, $new_todo and sync_lists();
	writefile();
}


sub todo_details
{
	my $index = get_existing_todo("show details for");
	return unless defined $index;
	input(PRESS_RETURN);
}


sub edit_todo
{
	my $index = get_existing_todo("edit");
	return unless defined $index;

	input_todo($todo_list[$index]);

	sync_lists();
	writefile();
}


sub push_date
{
	my $index = get_existing_todo("postpone");
	return unless defined $index;

	$todo_list[$index]->{due} = input_date($todo_list[$index]->{due});

	writefile();
}


sub cancel_todo
{
	my $index = get_existing_todo("cancel");
	return unless defined $index;

	print "A cancelled todo task is gone forever!!\n";
	if (get_yn("Are you sure you want to do this?"))
	{
		my $old_todo = splice @todo_list, $index, 1;
		sync_lists();
		save_history($parminfo->{user}, "cancel", todo_fields($old_todo));
		writefile();
	}
}


sub complete_todo
{
	my $index = get_existing_todo("complete");
	return unless defined $index;

	if (get_yn("Are you definitely ready to mark this task completed?"))
	{
		my $old_todo = splice @todo_list, $index, 1;
		sync_lists();
		save_history($parminfo->{user}, "complete", todo_fields($old_todo));
		writefile();
	}
}


sub refresh_list
{
	# clear the list, then reread the file: that refreshes the list
	undef @todo_list;
	readfile();
}


sub shift_schedule
{
	# determine oldest task
	my $oldest_todo = (sort { $a->{due} <=> $b->{due} } @todo_list)[0];
	my $old_date = $oldest_todo->{due};
	writeln('Oldest task is dated @m/#d/@y.', $old_date);

	print "Please enter a new date for this task.\n";
	my $new_date = input_date();

	my $shift_days = int(date::dayDiff($old_date, $new_date));
	print "All tasks will be moved forward $shift_days days.\n";
	if (get_yn("Are you sure?"))
	{
		foreach my $todo (@todo_list)
		{
			$todo->{due} = date::dateTimeSeconds(
					date::incDays($todo->{due}, $shift_days));
		}

		writefile();
	}
}


#################################
# SUBROUTINES
#################################

sub usage
{
	error(0, "usage is:\n",
			"    todo [-h | -f]\n",
			"       -h: this help message\n",
			"       -f: don't ask for confirmations\n",
	);
}


sub error
{
	my ($exitcode, @messages) = @_;
	my $progname = $0;
	$progname =~ s@.*/@@;
=comment
	if ($cgi)
	{
		foreach (@messages)
		{
			# s/\n/<BR>\n/g;
		}
		print @messages, "\n";
		exit 0;
	}
	else
=cut
	{
		print STDERR "$progname: ", @messages, "\n";
		exit $exitcode;
	}
}


sub initialize
{
	$parminfo->{user} ||= t3_username();

	readfile();
}


sub readfile
{
	open(IN, T3::base_filename(TODO => $parminfo->{user}))
			or die("can't read todo file");
	while ( <IN> )
	{
		chomp;

		my $todo = {};
		(todo_fields($todo)) = split("\t");

		# account for the possibility that due dates are stored as
		# date strings instead of time numbers (as they should be)
		$todo->{due} = str2time($todo->{due}) if $todo->{due} =~ m@/@;

		push @todo_list, $todo;
	}
	close(IN);

	sync_lists();
}


sub writefile
{
	open(OUT, ">" . T3::base_filename(TODO => $parminfo->{user}))
			or die("can't write todo file");
	foreach my $todo (@todo_list)
	{
		print OUT join("\t", todo_fields($todo)), "\n";
	}
	close(OUT);
}


# this keeps %todo_index sync'ed up with @todo_list.  you have to call
# this function yourself every time you modify @todo_list.

sub sync_lists
{
	%todo_index = map { $todo_list[$_]->{name} => $_ } 0..$#todo_list;
}


sub todo_menu_list
{
	my @menu_list = sort { $a->{due} <=> $b->{due} } @todo_list;
	foreach my $todo (@menu_list)
	{
		$todo = swrite(TodoList, todo_fields($todo)) . "\n";
	}
	return @menu_list;
}


sub menu_header
{
	if (@todo_list)
	{
		my $list_header = TodoListHeader . "\n";
		return join('', $list_header, todo_menu_list());
	}
	else
	{
		return "\n\tYou have no items in your todo list.\n\n";
	}
}


sub get_existing_todo
{
	my ($operation) = @_;

	my $name = input("What is the name of the task you want to $operation?");

	unless (exists $todo_index{$name})
	{
		print "No such task!\n";
		input(PRESS_RETURN);
		return undef;
	}

	my $todo = $todo_list[$todo_index{$name}];

	# retrieve full names from database
	foreach (
			[ "client",		"{~timer}.client",			"client_id",	false ],
			[ "project",	"{~timer}.project",			"proj_id",		true ],
			[ "phase",		"{~timer}.phase",			"phase_id",		false ],
			[ "tracking",	"{~timer}.client_tracking",	"tracking_code",true ],
			)
	{
		my ($which, $table, $id_col, $use_client) = @$_;

		# it's okay if the element is missing; just blank out and move on
		if (not $todo->{$which})
		{
			$todo->{$which} = $todo->{"${which}_name"} = "";
			next;
		}

		my $query = "
				select name from $table
				where $id_col = '$todo->{$which}'
			";
		$query .= " and client_id = '$todo->{client}'" if $use_client;

		$todo->{"${which}_name"} = one_datum($query);
	}

	# make a copy for the format, else the field itself will get eaten
	my $descr = $todo->{descr};
	writeln(TodoTask, @$todo{ qw<client client_name project project_name
			due phase phase_name tracking tracking_name> }, $descr);
	print "\n\n";

	return $todo_index{$name};
}


sub input_todo
{
	my ($todo) = @_;

	$todo->{descr} = input("Brief description of the task:", $todo->{descr});
	$todo->{due} = input_date($todo->{due});

	# need to save results in object, not parminfo
	my $opts = { SAVE_IN_OBJECT => 1 };
	get_parameter("client", $parminfo, $todo, $opts);
	get_parameter("project", $parminfo, $todo, $opts);
}


sub input_date
{
	my ($old_date) = @_;

	my $new_date = input(
			"When task is due:",
			$old_date ? swrite('@m/#d/@y', $old_date) : date::today(), 
			{
				CONVERT		=>	\&parse_date_spec,
				VALID_ERR	=>	"\a\a  >>Invalid Date!\n"
			}
	);

	return $new_date;
}


sub parse_date_spec
{
	# this style needs a little help (but just a little)
	if ($_[0] =~ /^\+(\d+)$/)
	{
		# interpret as number of days from today
		$_[0] .= " days";
	}

	# let parsedate do all the hard work
	return parsedate($_[0], PREFER_FUTURE => 1);
}


sub save_history
{
	my ($user, $command, @todo_fields) = @_;

	my $file = T3::hist_filename(TODO => $user);
	open(HIST, ">>$file") or die("can't open history file $file");
	print HIST join("\t", $ENV{USER}, date::today(), $command, $user,
			@todo_fields), "\n";
	close(HIST);
}
