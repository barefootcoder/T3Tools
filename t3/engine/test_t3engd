#! /usr/bin/perl

use strict;

use Barefoot::debug;						# comment out for production


use Barefoot::exception;
use Barefoot::T3::client;


# main ()

print "=" x 40, "\n";

test_bad_modules_dir_perms();
test_server_start();

# this loop tests mosts of the error checking stuff
# we used to do this several times, but now we think once is sufficient
# (just change the second "1" in the for below if you disagree)
for (1..1)
{
	# want to do this using child processes so they will have different pid's,
	# but can't reliably check log file if they all run at once, so we'll
	# just fork and wait for them ... simultaneous clients are tested later
	fork and wait and $? ? die("child died") : next;

	try
	{
		my $success = timeout
		{
			test_pipe_exists();
			test_bogus_request();
			test_unknown_module();
			test_bogus_output1();
			test_bogus_output2();
			test_bogus_output3();
		} 60;			# anything over a minute means something went wrong
		die("got stuck during testing") unless $success;
	}
	catch
	{
		test_server_shutdown();
		rethrow;				# don't lose original error
	};

	print "client run passed\n";
	exit 0;						# exit the child
}

my @children;					# save the child PIDs so we can reap them
for my $x (1..5)
{
	# this time we'll do things simultaneously
	my $pid;
	$pid = fork and push @children, $pid and next;

	try
	{
		test_test_module();
		test_large_output_module();
	}
	catch
	{
		test_server_shutdown();
		rethrow;				# don't lose original error
	};

	print "client run passed\n";
	exit 0;						# exit the child;
}
my $success = timeout
{
	foreach my $pid (@children)
	{
		waitpid $pid,0;
		die("child $pid failed") if $?;
	}

} 60;
die("got stuck while testing simultaneous processes") unless $success;

test_server_shutdown();
test_pipe_cleanup();

# they all worked!
print "ALL TESTS PASSED\n";


# subs

sub get_last_log
{
	# sometimes we try to read the log before the server's finished
	# writing ... so we give ourselves a slight delay to help out
	sleep 1;
	my $msg = `tail -1 t3engd.log`;
	chomp $msg;
	return $msg;
}

sub test_bad_modules_dir_perms
{
	chmod 0777, "modules";			# these are bad permissions
	my $error_catch = "s.errors";
	system("t3engd 2>$error_catch &");
	sleep 1;
	my $errs = `cat $error_catch`;
	unlink $error_catch;
	if (`ps aux | grep 'perl -Tw .*t3engd'`
			or $errs !~ /^modules directory has too many permissions /)
	{
		test_server_shutdown();
		die("server did not detect bad perms on modules directory");
	}
	chmod 0700, "modules";			# good permissions for further testing
}

sub test_server_start
{
	system("t3engd &");
	sleep 1;
	die("can't start server for testing")
			unless `ps aux | grep 'perl -Tw .*t3engd'`;
}

sub test_pipe_exists
{
	sleep 1;
	die("request pipe doesn't exist") unless -p T3::REQUEST_FILE;
}

sub test_bogus_request
{
	T3::Client::send_request("bogus");
	# print STDERR "last log is: ", get_last_log(), "<<\n";
	die("didn't gracefully handle bogus request")
			unless get_last_log() =~ /: malformed request/;
}

sub test_unknown_module
{
	T3::Client::send_request("module=bogus");
	die("didn't gracefully handle bogus module")
			unless get_last_log() =~ /: unknown module/;
}

sub test_bogus_output1
{
	T3::Client::send_request("module=test");
	die("didn't gracefully handle bogus output pipe")
			unless get_last_log() =~ /: output pipe name invalid/;
}

sub test_bogus_output2
{
	T3::Client::send_request("module=test output=");
	die("didn't gracefully handle bogus output pipe")
			unless get_last_log() =~ /: output pipe name invalid/;
}

sub test_bogus_output3
{
	T3::Client::send_request("module=test output=bogus");
	die("didn't gracefully handle bogus output pipe")
			unless get_last_log() =~ /: output pipe name invalid/;
}

sub test_test_module
{
	T3::Client::send_request("module=test output=$$");
	my @test_output = T3::Client::retrieve_output($$);
	print STDERR ">>>", @test_output, "<<<\n" and
	die("test module returned incorrect output")
			unless @test_output == 1 and $test_output[0] eq "TEST OUTPUT\n";
}

sub test_large_output_module
{
	T3::Client::send_request("module=large_output output=$$");
	my @test_output = T3::Client::retrieve_output($$);
	die("large output module returned incorrect output")
			unless @test_output == 1_000
			and ! grep { $_ ne "TEST." x 100 . "\n" } @test_output;
}

sub test_server_shutdown
{
	T3::Client::send_request("SHUTDOWN");
	system("kill `ps aux | grep 'perl -Tw .*t3engd' | awk '{print \$2}'`") and
	die("server refuses to shutdown")
			if `ps aux | grep 'perl -Tw .*t3engd'`;
}

sub test_pipe_cleanup
{
	die("server didn't clean up pipe") if -e T3::REQUEST_FILE;
	die("client(s) didn't clean up pipe(s)") if glob("t3.output.*");
}
