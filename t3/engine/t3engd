#! /usr/bin/perl -Tw

use strict;

use Barefoot::debug;						# comment out for production
#use Barefoot::debug_verbose;				# comment out for production

use Fcntl;
use FileHandle;
use File::Basename;
use Barefoot::exception;
use Barefoot::T3::common;

# system paths
use constant MKFIFO => '/usr/bin/mkfifo';

setup_modules();


# main ()

open(LOG, ">t3engd.log") or die("can't create log file");
LOG->autoflush();
log_error("starting server");

create_pipe(T3::REQUEST_FILE);


# the open will block until it receives a request
T3::debug("before initial open");
open_request_pipe();
T3::debug("after initial open");
while (1)
{
	my $request = <PIPE>;
	if (not $request)				# got EOF; close pipe and reopen
	{
		close(PIPE);
		open_request_pipe();
		next;
	}

	chomp($request);
	T3::debug("request is $request");
	if ($request eq "SHUTDOWN")
	{
		# handle shutdown requests right here
		shutdown_server();
	}
	else
	{
		# parse request string and test for errors
		my $req = parse_request_string($request);
		next unless $req;			# indicates error in parsing

		my $module = $req->{module};
		T3::debug("module is module");
		unless ($req->{output})
		{
			log_error("output pipe name invalid or missing");
			next;
		}

		T3::debug("pipe name is $req->{output}");
		my $pipe = open_output_pipe($req->{output});
		if ($pipe)
		{
			my $oldfh = select($pipe);
			$| = 1;

			my @input_lines;
			if ($req->{lines})
			{
				T3::debug("now reading $req->{lines} lines of input");
				for (1..$req->{lines})
				{
					my $line = <PIPE>;
					next unless $line;
					push @input_lines, $line;
				}
			}

			T3::execute_module($module, @input_lines);
			select($oldfh);
			$pipe->close() unless exists $req->{combine_next};
		}
		else
		{
			log_error("can't build output pipe [$req->{output}]");
		}
	}
}
# this really shouldn't be possible ...
die("popped out of infinite loop");


# subs

sub setup_modules
{
	my $mod_dir = DEBUG ? T3::TEST_MODULES_DIR
			: T3::config_param("SERVER", "ModulesDir");
	T3::debug("modules directory is $mod_dir");
	die("modules directory parameter not set in config file") unless $mod_dir;
	die("modules directory $mod_dir is not accessible") unless -d $mod_dir;

	# now make sure this directory looks secure
	# we're going to be untainting all filenames in this directory, so we
	# better be damned sure it's okay
	# first, make sure owner matches t3engd's owner
	die("modules directory is not owned by t3engd owner")
			unless (stat $0)[4] == (stat $mod_dir)[4];
	# now make sure owner is the one running the daemon
	die("modules directory is not owned by euid") unless -o $mod_dir;
	# now that the owner is cool, just make sure no one else has perms
	die("modules directory has too many permissions (should be 700 max)")
			if (stat $mod_dir)[2] & 077;

	foreach my $file (glob("$mod_dir/*.pm"))
	{
		# blatant untainting now that we're satisfied with the perms
		($file) = $file =~ /^(.*)$/;
		require $file;
	}
}

sub log_error
{
	my ($msg) = @_;

	print LOG "$0: $msg at ", scalar(localtime(time())), "\n";
}

sub create_pipe
{
	my ($pipe_file) = @_;

	unlink($pipe_file) if -e $pipe_file;
	T3::debug(-e $pipe_file ? "pipe exists" : "pipe is gone");
	log_error($!) if system(MKFIFO, $pipe_file);
}

sub open_request_pipe
{
	T3::debug("about to open pipe " . T3::REQUEST_FILE);
	T3::debug(-p T3::REQUEST_FILE ? "file is a pipe" : "file is not a pipe");
	# T3::debug("fuser says " . `/usr/sbin/fuser -u ./t3.request`);

	# a regular open wasn't working here, but I don't know why ...
	# sysopen seems to have solved the problem (for now)
	sysopen(PIPE, T3::REQUEST_FILE, O_RDONLY)
			or die("can't open the request pipe for reading");
	T3::debug("got pipe open");
}

sub parse_request_string
{
	my $req = {};
	foreach (split(' ', $_[0]))
	{
		if ( /(\w+)=(.*)/ )
		{
			T3::debug(2, "parse request: setting $1 to $2");
			$req->{$1} = $2;
		}
		else
		{
			log_error("malformed request [$_[0]]");
			return undef;
		}
	}

	# check for basic errors
	log_error("missing module name [$_[0]]") and return undef
			unless exists $req->{module};
	log_error("unknown module [$req->{module}]") and return undef
			unless T3::exists_module($req->{module});

	return $req;
}

sub open_output_pipe
{
	my ($id) = @_;

	T3::debug("pipe id is $id");
	if (not $id)
	{
		log_error("output pipe name invalid");
		return undef;
	}

	my $pipe_file = T3::OUTPUT_FILE . $id;
	create_pipe($pipe_file);
	return new FileHandle(">$pipe_file");
}

sub shutdown_server
{
	unlink(T3::REQUEST_FILE) or log_error("couldn't remove input pipe");
	log_error("shutting down");
	exit 0;
}
